\documentclass{llncs}

\usepackage{a4wide}
\usepackage{amsmath,amssymb}

\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}

\newcommand{\Zbb}{\mathbb{Z}}

\newcommand{\ID}{\mathit{ID}}
\newcommand{\TA}{\mathit{TA}}

\newcommand{\mpk}{\mathit{mpk}}
\newcommand{\msk}{\mathit{msk}}

\newcommand{\getsr}{\stackrel{{\scriptscriptstyle\$}}{\gets}}
\newcommand{\adv}[2]{\mathit{Adv}_{#1}^{\tiny \texttt{#2}}}

\title{Multiple Hierarchy Wildcard Encryption}
\author{All Who Want To Play}
\institute{...}

\begin{document}
\maketitle

\begin{abstract}
expressionism is an art movement typically characterised by its
non-realistic representation of non-tangible nouns (such as emotions
or situations). It centred in the New York in the post-surrealistic
decades after the second World War, and, in particular, around Peggy
Guggenheim's gallery ``Art of this Century''.
\end{abstract}

\section{Syntax}

A multi-hierarchy WIBE consists of the following PPT
algorithms/protocols:
\begin{itemize}
\item $\texttt{Setup}(1^{k},\TA)$: This algorithm is run
once by a TA and outputs a master public key and master private key
for that TA $(\mpk_{\TA},\msk_{\TA})\getsr
\texttt{Setup}(1^{k},\TA)$. \medskip

\emph{What's to prevent an attacker setting up his own TA under the
name of a real coalition member and then hijacking the update
coalition protocol? Are we going to assume trusted distribution of
master public keys?}\medskip

\item
$\texttt{SetupCoalitionBroadcast}(\TA,\msk_{\TA},(\TA_{1},\mpk_{\TA_{1}}),\ldots,
(\TA_{n},\mpk_{\TA_{n}}))$: This algorithm creates a coalition
between a set of TAs $\mathcal{C} = (\TA_{1},\ldots,\TA_{n})$. This
algorithm outputs a list of messages $w_{i}$ to be sent to the TA
$\TA_{i}$
$((\TA_{1},w_{\TA_{1}}),\ldots,(\TA_{n},w_{\TA_{n}}))$.\medskip

\item $\texttt{SetupCoalitionKeys}(\TA,\msk_{\TA},(\TA_{1},\mpk_{\TA_{1}},w_{1}),\ldots,
(\TA_{n},\mpk_{\TA_{n}},w_{n}))$: The algorithm completes the setup
of the coalition. After every member $\TA_{i}$ of the coalition has
provided a message $w_{i}$ for $\TA$. It outputs a message $u_{\TA}$
to be broadcast to every member of its hierarchy.
\end{itemize}
The system should be able to dynamically update the coalition. We
may wish to change a coalition $\mathcal{C}$ into a coalition
$\mathcal{C}'$. We assume that members $\mathcal{C} \cap
\mathcal{C}'$ execute the $\texttt{UpdateCoalition}$ algorithms,
while new members $\mathcal{C}\setminus \mathcal{C}'$ execute the
$\texttt{JoinCoalition}$ algorithms. Excluded members
$\mathcal{C}'\setminus \mathcal{C}$ are simply informed that they
are no longer members of the coalition.
\begin{itemize}
%\item
%$\texttt{AddCoalitionBroadcast}(\TA,\msk_{\TA},(\TA'_{1},\mpk_{\TA'_{1}}),\ldots,(\TA'_{n'},\mpk_{\TA_{n'}}))$:
%This algorithm adds authorities $(\TA'_{1},\ldots,\TA'_{n'})$ to an
%existing coalition. Each existing coalition member $\TA$ runs this
%algorithm and sends the result messages $(w'_{1},\ldots,w'_{n'})$ to
%the appropriate new TAs.\medskip
%
%\item
%$\texttt{AddCoalitionKeys}(\TA,\msk_{\TA},(\TA'_{1},\mpk_{\TA'_{1}},w'_{1}),\ldots,(\TA'_{n'},\mpk_{\TA_{n'}},w'_{n}))$:
%This algorithm outputs a message $u_{\TA}$ to be broadcast to its
%own hierarchy in order to re-key the coalition.\medskip

\item $\texttt{UpdateCoalitionBroadcast}(\TA,\msk_{\TA},(\TA_{1},\mpk_{\TA_{1}}),\ldots,
(\TA_{n},\mpk_{\TA_{n}}))$: This algorithm updates an existing
coalition $\mathcal{C}$ contain $\TA$ to become a new coalition
$\mathcal{C}'=(\TA,\TA_{1},\ldots,\TA_{n})$. This algorithm outputs
a list of messages $w_{i}$ to be sent to the TA $\TA_{i}$. It should
be noted that some $w_{i}$ may be empty, particularly if $\TA_{i}\in
\mathcal{C}$.\medskip

\item $\texttt{Join CoalitionBroadcast}(\TA,\msk_{\TA},(\TA_{1},\mpk_{\TA_{1}}),\ldots,
(\TA_{n},\mpk_{\TA_{n}}))$: A new authority $\TA$ which is joining
an existing coalition to form a new coalition
$\mathcal{C}'=(\TA,\TA_{1},\ldots,\TA_{n})$ uses this algorithm to
produce a series of messages $w_{i}$ to be sent to
$\TA_{i}$.\medskip

\item $\texttt{UpdateCoalitionKeys}(\TA,\msk_{\TA},(\TA_{1},\mpk_{\TA_{1}},w_{1}),\ldots,
(\TA_{n},\mpk_{\TA_{n}},w_{n}))$: The algorithm completes the
updating of the coalition for existing members. After every member
$\TA_{i}$ of the coalition has provided a (non-empty) message
$w_{i}$ for $\TA$. It outputs a message $u_{\TA}$ to be broadcast to
every member of its hierarchy.\medskip

\item $\texttt{JoinCoalitionKeys}(\TA,\msk_{\TA},(\TA_{1},\mpk_{\TA_{1}},w_{1}),\ldots,
(\TA_{n},\mpk_{\TA_{n}},w_{n}))$: This algorithm completes the
joining of an existing coalition for new members. After every member
$\TA_{i}$ of the coalition has provided a (non-empty) message
$w_{i}$ for $\TA$, this algorithm outputs a message $u_{\TA}$ to be
broadcast to every member of its hierarchy.
\end{itemize}
We now describe the algorithms required by the individual users.
\begin{itemize}
\item $\texttt{Extract}(\vec{ID},\ID',d_{\vec{\ID}})$: This
algorithm outputs a decryption key $d_{\vec{\ID}\|\ID}$ for the
identity $\vec{\ID} \| \ID$. The basic level has $\ID=\TA$ and
$d_{\TA}=\msk_{\TA}$. \medskip

\item
$\texttt{ExtractCoalitionKey}((\TA_{1},\ldots,\TA_{n}),u_{\TA},d_{\ID})$:
This algorithm outputs a user key $c_{\ID}$ for the coalition
$\mathcal{C}=\{\TA,\TA_{1},\ldots,\TA_{n}\}$ by combining the
broadcast key $u_{\TA}$ and their decryption key $d_{\ID}$.\medskip

\item $\texttt{UpdateCoalitionKey}((\TA_{1},\ldots,\TA_{n}),u_{\TA},c_{\ID},d_{\ID})$:
This algorithm outputs an updated user key $c'_{\ID}$ for the
coalition $\mathcal{C}=\{\TA,\TA_{1},\ldots,\TA_{n}\}$ by combining
the broadcast key $u_{\TA}$ with the user's decryption key $d_{\ID}$
and existing coalition key $c_{\ID}$.\medskip

\item $\texttt{Encrypt}((\TA_{1},\mpk_{\TA_{1}}),\ldots,(\TA_{1},\mpk_{\TA_{1}}),\mathit{P},m)$:
This algorithm is used to encrypt a message $m$ to entities
satisfying the pattern $\mathit{P}$ under the coalition formed by
$(\TA_{1},\ldots,\TA_{n})$. It outputs a ciphertext $C$ or the
invalid symbol $\perp$.
\medskip

\item $\texttt{Decrypt}$: It does what you'd expect...
\end{itemize}

\section{Security Model}

The security model is parameterised by a bit $b$ involves a PPT
attacker $\A$ which is initially given the input $1^k$ and access to
the following oracles:
\begin{itemize}
\item $\texttt{CreateTA}(\TA)$: The oracle computes
$(\mpk_{\TA},\msk_{\TA})\getsr \texttt{Setup}(1^{k},\TA)$ for the TA
identity $\TA$ and returns $\mpk_{\TA}$. This oracle can only be
queried once for each identity $\TA$.\medskip

\item
$\texttt{SetupCoalitionBroadcast}(\TA,(\TA_{1},\ldots,\TA_{n}))$:
This oracle runs the $\texttt{SetupCoalitionBroadcast}$ algorithm on
the appropriate inputs and returns $(w_{1},\ldots,w_{n})$.\medskip

\item $\texttt{SetupCoalitionKeys}(\TA, (w_{1},\ldots,w_{n}))$: This
oracle can only be queried if $\TA$ has been queried to the
$\texttt{SetupCoalitionBroadcast}$ oracle with $n$ $\TA$'s in the
coalition. The oracles runs the $\texttt{SetupCoalitionKeys}$
algorithm assuming that message $w_{i}$ was sent by $\TA_{i}$. Note
that this does not imply that all the TAs believe that they're in
the same coalition.\medskip

\item $\texttt{UpdateCoalition}$ oracles are similar to the
above...\medskip

\item $\texttt{CorruptTA}(\TA)$: The oracle returns $\msk_{\TA}$ and
records that $\TA$ is corrupt.\medskip

\item $\texttt{CorruptUser}(\TA,\vec{\ID})$: This oracle returns
$d_{\vec{\ID}}$ for the identity $\vec{\ID}$ under the authority
$\TA$. Note that given $d_{\vec{\ID}}$ the attacker can compute any
coalition key $c_{\vec{\ID}}$. \medskip

\item $\texttt{UserDecrypt}(\TA,\vec{\ID},C^{*})$: This oracle
decrypts the ciphertext with the decryption key
$d_{\vec{\ID}}$.\medskip

\item $\texttt{CoalitionDecryption}(\TA,\vec{\ID},C^{*})$: This oracle
decrypts the ciphertext with the decryption key
$c_{\vec{\ID}}$.\medskip

\item
$\texttt{Test}(\TA_{1},\ldots,\TA_{n},\mathit{P},m_{0},m_{1})$: This
oracle takes as input two messages $(m_{0},m_{1})$ of equal length.
It encrypts the message $m_{b}$ for the coalition using
$(\mpk_{\TA_{1}},\ldots,\mpk_{\TA_{n}})$ under the pattern
$\mathit{P}$. This oracle may only be access once and outputs a
ciphertext $C^{*}$. We will let $\mathcal{C}^{*}$ denote the
challenge coalition $(\TA_{1},\ldots,\TA_{n})$.
\end{itemize}
The attacker terminates by outputting a bit $b'$. The attacker's
advantage is defined to be:
\begin{displaymath}
\adv{\A}{IND}(k) = |Pr[b'=1|b=1]-Pr[b'=1|b=0]| \, .
\end{displaymath}
The disallowed oracle queries: (1) a \texttt{CorruptTA} query for
any TA in the test coalition , (2) a \texttt{CorruptUser} query for
any user $\ID$ matching the pattern $\mathit{P}$ under an authority
$\TA$ in the test coalition if there has been a
\texttt{SetupCoalitionKeys} or \texttt{UpdateCoalitionKeys} query
for the test coalition, (3) a decrypt query for $C^{*}$ and any user
$\ID$ matching the pattern $\mathit{P}$ under an authority $\TA$ in
the test coalition if there has been a \texttt{SetupCoalitionKeys}
or \texttt{UpdateCoalitionKeys} query for the test coalition.


\section{BB-Based Construction}

We may instantiate this notion using the Boneh-Boyen WIBE. We assume that there exists a set of bilinear map groups $G, G_{T}$ of large prime order $p$ and a bilinear map $e: G \times G \rightarrow G_{T}$. We assume the existence of two randomly chosen generators $g_{1},g_{2}\getsr G^{*}$. We also assume that there exist $2L+2$ randomly chosen group elements $u_{i,j} \getsr G_{2}$ where $i\in \{0,1,2,\ldots,L\}$ and $j\in \{0,1\}$ and $L$ is a limit on the maximum depth in a hierarchy. The MTA-WIBE is described as follows:

\begin{itemize}
\item $\texttt{CreateTA}(\TA)$: The TA generates $\alpha \getsr \Zbb_{p}$ and computes master public key $\mpk_{\TA} \gets g_{1}^{\alpha}$. The master private key is defined to be $g_{2}^{\alpha}$.\medskip

\item $\texttt{Extract}(\vec{ID},\ID',d_{\vec{\ID}})$: For the first level identity $\ID_{1}$, the TA generates $r_{0},r_{1}\getsr \Zbb_{p}$ and computes the pair $(h,a_{0},a_{1})$ where $h\gets g_{2}^{\alpha}(u_{0,0} \cdot u_{0,1}^{\TA})^{r_{0}}(u_{1,0} \cdot u_{1,1}^{\ID_{1}})^{r_{1}}$, $a_{0}\gets g_{1}^{r_{0}}$ and $a_{1} \gets g_{1}^{r_{1}}$. An identity $(\ID_{1},\ldots,\ID_{\ell})$ with private key $(h,a_{0},a_{1},\ldots,a_{\ell})$ and $\ell < L$ can compute the decryption key for its child $(\ID_{1},\ldots,\ID_{\ell},\ID_{\ell+1})$ by choosing a random value $r_{\ell+1}$ and computing the private key as the tuple $(h',a_{0},a_{1},\ldots,a_{\ell},a_{\ell+1})$ where $h' \gets h(u_{\ell+1,0}\cdot u_{\ell+1,1}^{\ID_{\ell+1}})^{r_{\ell+1}}$ and $a_{\ell+1}\gets g_{1}^{r_{\ell+1}}$.\medskip

\item
$\texttt{SetupCoalitionBroadcast}(\TA,(\TA_{1},\ldots,\TA_{n}))$: For $1\leq j\leq n$, $\TA$ randomly generates $r_{j}\getsr \Zbb_{p}$ for $1\leq j\leq n$ and computes $w_{j,0} \gets g_{2}^\alpha(u_{0,0} \cdot u_{0,1}^{\TA_{j}})^{r_{j}}$ and $w_{j,1} \gets g_{1}^{r_{j}}$ where $\TA_{j} \in \Zbb_{p}$ is the identity of $\TA_{j}$. The algorithm sets $w_{j}=(w_{j,0},w_{j,1})$ and outputs a list of TA/message pairs $((\TA_{j},w_{j}))_{j=1}^{n}$. \medskip

\item $\texttt{SetupCoalitionKeys}(\TA,\msk_{\TA},(\TA_{1},\mpk_{\TA_{1}},w_{1}),\ldots,
(\TA_{n},\mpk_{\TA_{n}},w_{n}))$: The algorithm outputs the message $u_{\TA} \gets (w_{j})_{j=1}^{n}$. \medskip

\item
$\texttt{ExtractCoalitionKey}((\TA_{1},\ldots,\TA_{n}),u_{\TA},d_{\ID})$: Parse $u_{\TA}$ as $(w_{j})$ where $w_{j,0} = g_{2}^{\alpha_{j}}(u_{0,0} \cdot u_{0,1}^{\TA})^{r_{j}}$ and $w_{j,1} = g_{1}^{r_{j}}$ (where $g_{2}^{\alpha_{j}}$ is the private key of $\TA_{j}$). A user with private key $(h,a_{0},a_{1},a_{2},\ldots,a_{\ell})$ can form a coalition key $(h',a'_{0},a_{1},a_{2},\ldots,a_{\ell})$ where
\begin{displaymath}
\begin{array}{c}
h \gets h \prod_{j=1}^{n} w_{j,0} = g_{2}^{\alpha + \sum \alpha_{j}}(u_{0,0} \cdot u_{0,1}^{\TA})^{r + \sum r_{j}} \\
a'_{0} \gets a_{0} \prod_{j=1}^{n} w_{j,1} = g_{1}^{r+\sum r_{j}}
\end{array}
\end{displaymath}
\item $\texttt{Encrypt}((\TA_{1},\mpk_{\TA_{1}}),\ldots,(\TA_{n},\mpk_{\TA_{n}}),\mathit{P},m)$:
    Let $\ell$ be the depth of the pattern and $W(P)$ be the set of levels which have wildcard characters. The sender chooses $t\gets \Zbb_{p}$ and computes the ciphertext $C=(C_{1},C_{2,0},C_{2,1},...,C_{2,\ell},C_{3})$ where
    \begin{displaymath}
    \begin{array}{lcl}
    C_{1} &\gets& g_{1}^{t} \\
    C_{2,0} &\gets& (u_{0,0}\cdot \prod_{i=1}^{n} u_{0,1}^{\TA_{i}})^{t}\\
    C_{2,i} &\gets& \left\{
    \begin{array}{ll}
    (u_{i,0} \cdot u_{i,1}^{\ID_{i}})^{t} & \qquad \mbox{if } i \notin W(P) \\
    (u_{i,0}^{t},u_{i,1}^{t}) & \qquad \mbox{if } i \in W(P)
    \end{array}
    \right. \\
    C_{3} &\gets& m \cdot e(\prod_{j=1}^{n} \mpk_{\TA_{j}},g_{2})^{t}
    \end{array}
    \end{displaymath}
\item $\texttt{Decrypt}(\ID,c_{\ID},C)$: Parse $\ID$ as $(\ID_{1},\ldots,\ID_{\ell})$, $c_{\ID}$ as $(h,a_{0},\ldots,a_{\ell})$, and $C$ as $(C_{1},C_{2,0},\ldots,C_{2,\ell},C_{3})$. For each $i\in W(P)$, parse $C_{2,i}$ as $(v_{i,0},v_{i,1})$. We recover a complete HIBE ciphertext by setting $C'_{2,0} \gets C_{2,0}$, $C'_{2,i} \gets C_{2,i}$ if $i\notin W(P)$, and $C_{2,i}\gets v_{i,0} \cdot v_{i,1}^{\ID_{i}}$ if $i\in W(P)$. Recover
    \begin{displaymath}
    m' \gets C_{3} \frac{\prod_{i=0}^{\ell} e(a_{i},C'_{2,i})}{e(C_{1},h)}
    \end{displaymath}
    and return $m'$.
\end{itemize}

We define a HIBE in exactly the same way except that we remove the possibility that the pattern can contain wildcards.

\begin{theorem}
Suppose that there exists an attacker $\A$ against the selective-identity multiple TA Boneh-Boyen WIBE that runs in time $t$ and with advantage $\epsilon$, then there exists an attacker $\B$ against the selective-identity multiple TA Boneh-Boyen HIBE that runs in time $t'$ and with advantage $\epsilon'$ where $t \approx t'$ and $\epsilon' = \epsilon$.
\end{theorem}
\emph{Proof} We directly describe the algorithm $\B$ which breaks the HIBE using the algorithm $\A$ as a subroutine. The algorithm $\B$ runs as follows:
\begin{enumerate}
\item $\B$ runs $\A$ on the security parameter. $\A$ responds by outputting a description of the challenge coalition $\TA^{*} = (\TA^{*}_{1},\ldots,\TA^{*}_{n})$ and the challenge pattern $P^{*} = (P^{*}_{1},\ldots,P^{*}_{\ell^{*}})$. Let $\pi$ be a map which identifies the number of non-wildcard entries in the first $i$ layers of $P^{*}$, i.e. $\pi(i) = i - |W(P^{*}_{\leq i})|$. $\B$ outputs the challenge coalition $\TA^{*}$ and the challenge identity $\hat{\ID}^{*}=(\hat{\ID}^{*}_{1},\ldots,\hat{\ID}^{*}_{\pi(\ell^{*})})$ where $\hat{\ID}^{*}_{i} = P^{*}_{\pi(i)}$.
\item The challenger responds with HIBE parameters $\mathit{param} = (\hat{g}_{1},\hat{g}_{2},\hat{u}_{0,0},\ldots,\hat{u}_{L,1})$. $\B$ generates WIBE parameters as follows:
    \begin{displaymath}
    \begin{array}{rcll}
    (g_{1},g_{2}) &\gets& (\hat{g}_{1},\hat{g}_{2})&\\
    u_{i,j} &\gets& \hat{u}_{\pi{i},j} &\mbox{ for } i\notin W(P^{*}), j\in\{0,1\}\\
    u_{i,j} &\gets& g_{1}^{\beta_{i,j}} &\mbox{ for } i\in W(P^{*}), j\in\{0,1\}\mbox{ where } \beta_{i,j}\getsr \mathbb{Z}_{p}\\
    u_{i,j} &\gets& \hat{u}_{i-|W(P^{*})|,j} &\mbox{ for } i\in \{\ell+1,\ldots,L\}, j\in\{0,1\}
    \end{array}
    \end{displaymath}
\item $\B$ executes $\A$ on the public parameters $(g_{1},g_{2},u_{0,0},\ldots,u_{L,1})$. $\A$ may make the following oracle queries:
    \begin{itemize}
    \item $\texttt{CreateTA}$: $\B$ forwards this request to its own oracle and returns the response.
    \item $\texttt{CoruptTA}$: $\B$ forwards this request to its own oracle and returns the response.
    \item $\texttt{SetupCoalitionBroadcast}$: $\B$ forwards this request to its own oracle and returns the response.
    \item $\texttt{SetupCoalitionKeys}$: $\B$ forwards this request to its own oracle and returns the response.
    \item $\texttt{Extract}$: To an extract a decryption key for an identity $\ID=(\ID_{1},\ldots,\ID_{\ell})$ which does not match the challenge pattern, $\B$ computes the projection of the identity onto the HIBE identity space to give a projected identity $\hat{\ID}=(\hat{\ID}_{1}\ldots, \hat{\ID}_{\hat{\ell}})$.
        \begin{itemize}
        \item If $\ell \leq \ell^{*}$ then $\hat{\ell} \gets \pi(\ell)$ and $\hat{\ID}_{\pi(i)} \gets \ID_{i}$ for $i\notin W(P^{*}_{\leq \ell})$. Since $\ID$ does not match the challenge pattern for the WIBE, we have that $\hat{\ID}$ does not match the challenge identity for the HIBE. $\B$ queries its $\texttt{Extract}$ on $\hat{\ID}$ and receives $(\hat{h},\hat{a}_{0},\ldots,\hat{a}_{\hat{\ell}})$ in response. $\B$ now ``retro-fits'' to find a complete key, by setting
            \begin{displaymath}
            \begin{array}{rcl}
            a_{0} &\gets& \hat{a}_{0}\\
            a_{i} &\gets& \hat{a}_{\pi(i)} \qquad \;\mbox{ for }1\leq i\leq \ell \mbox{ and } i\notin W(P^{*}_{\leq \ell})\\
            a_{i} &\gets& g_{1}^{r_{i}} \qquad \quad \mbox{ for }1\leq i\leq \ell \mbox{ and } i\in W(P^{*}_{\leq \ell})\mbox{ where } r_{i}\getsr \mathbb{Z}_{p}\\
            h &\gets& \hat{h} \prod_{i=1, i\in W(P^{*}_{\leq \ell})}^{\ell} (u_{i,0} \cdot u_{i,1}^{\ID_{i}})^{r_{i}}
            \end{array}
            \end{displaymath}
            and returning the key $(h,a_{0},\ldots,a_{\ell})$.
        \item If $\ell > \ell^{*}$, then $\hat{\ell} = \ell - |W(P^{*})|$, $\hat{\ID}_{\pi(i)} \gets \ID_{i}$ for $1\leq i\leq \ell^{*}$ and $i\notin W(P^{*})$, and $\hat{\ID}_{i-|W(P^{*})|} \gets \ID_{i}$ for $\ell^{*} < i\leq \ell$. Since $\ID$ does not match the challenge pattern for the WIBE, we have that $\hat{\ID}$ does not match the challenge identity for the HIBE. $\B$ queries its $\texttt{Extract}$ on $\hat{\ID}$ and receives $(\hat{h},\hat{a}_{0},\ldots,\hat{a}_{\hat{\ell}})$ in response. $\B$ now ``retro-fits'' to find a complete key, by setting
            \begin{displaymath}
            \begin{array}{rcl}
            a_{0} &\gets& \hat{a}_{0}\\
            a_{i} &\gets& \hat{a}_{\pi(i)} \qquad \qquad \; \,\mbox{ for }1\leq i\leq \ell^{*} \mbox{ and } i\notin W(P^{*})\\
            a_{i} &\gets& g_{1}^{r_{i}} \qquad \qquad \quad \, \mbox{ for }1\leq i\leq \ell^{*} \mbox{ and } i\in W(P^{*})\mbox{ where } r_{i}\getsr \mathbb{Z}_{p}\\
            a_{i} &\gets& \hat{a}_{i-|W(P^{*})|} \qquad \mbox{ for } \ell^{*} <i\leq \ell\\
            h &\gets& \hat{h} \prod_{i=1, i\in W(P^{*})}^{\ell^{*}} (u_{i,0} \cdot u_{i,1}^{\ID_{i}})^{r_{i}}
            \end{array}
            \end{displaymath}
            and returning the key $(h,a_{0},\ldots,a_{\ell})$.
            \item $\texttt{Test}$: If $\A$ queries the test oracle on two equal-length messages $(m_{0},m_{1})$, then $\B$ forwards this query on to its own $\texttt{Test}$ oracle. The oracle returns $(C^{*}_{1},C^{*}_{2,0},\hat{C}^{*}_{2,1},\ldots,\hat{C}^{*}_{2,\pi(\ell^{*})},C^{*}_{3})$. $\B$ retro-fits this to form a challenge ciphertext for $\A$, by setting
                \begin{displaymath}
                \begin{array}{rcll}
                C^{*}_{2,i} &\gets& \hat{C}^{*}_{2,\pi(i)} & \qquad \mbox{ for } 1\leq i\leq \ell^{*}, i\notin W(P^{*})\\
                C^{*}_{2,i} &\gets& (\psi(C^{*}_{1})^{\beta_{i,0}},\psi(C^{*}_{1})^{\beta_{i,1}}) & \qquad \mbox{ for } 1\leq i\leq \ell^{*}, i\in W(P^{*})
                 \end{array}
                \end{displaymath}
                $\B$ returns $(C^{*}_{1},C^{*}_{2,0},\ldots,C^{*}_{2,\ell^{*}},C_{3})$ to $\A$ as the challenge ciphertext.
        \end{itemize}
        $\A$ terminates by outputting a big $b'$ as its guess for the challenge bit $b$.
    \end{itemize}
    \item $\B$ outputs the bit $b'$.
\end{enumerate}
The algorithm $\B$ correctly simulates the oracles to which $\A$ has access; furthermore, $\B$ wins the HIBE game if and only if $\A$ wins the game. Hence, we have the theorem. \qed

\begin{theorem}
If there exists an attacker $\A$ against the selective-identity multiple TA IND-WID-CPA secure of the Boneh-Boyen HIBE that runs in time $t$ and has advantage $\epsilon$, then there exists an algorithm $\B$ that solves the DBDH problem that runs in time $t'=O(t)$ and has advantage $\epsilon' \geq \epsilon -q_{K}/p$.
\end{theorem}
\emph{Proof} We directly describe the algorithm $\B$ against the DBDH problem:
\begin{enumerate}
\item $\B$ receives the input $(g,g^{a},g^{b},g^{c},Z)$.
\item $\B$ runs $\A$ to obtain the challenge coalition $\TA^{*}=\{\TA^{*}_{1},\ldots,\TA^{*}_{n^{*}}\}$ and the challenge identity $\vec{\ID^{*}}=(\ID^{*}_{1},\ldots,\ID^{*}_{\ell^{*}})$ under the challenge trust authority $\TA^{*}_{1}$. (We assume, without loss of generality, that the challenge identity is under the trusted authority $\TA_{1}$.)
\item If $\ell^{*} < L$ then randomly generates $\ID^{*}_{\ell^{*}+1},\ldots,\ID^{*}_{L}\getsr \Zbb_{p}$.
\item $\A$ computes the challenge parameters
    \begin{displaymath}
    \begin{array}{c}
    g_{1} \gets g \qquad g_{2}\gets g^{b} \qquad \alpha_{i,j}, \beta_{j} \getsr \Zbb_{p}^{*} \mbox{ for } 0\leq i\leq L, j\in \{0,1\}\\
    \mpk_{\TA_{1}} \gets g^{a}/g^{\sum_{j=2}^{n^{*}} \beta_{j}} \qquad \mpk_{\TA_{j}} \gets g^{\beta_{j}} \mbox{ for } 2\leq j\leq n^{*}\\
    u_{0,0} \gets g_{1}^{\alpha_{0,0}}\cdot (g^{a})^{-\TA^{*}_{1}\alpha_{0,1}} \qquad u_{0,1} \gets (g^{a})^{\alpha_{0,1}}\\
    u_{i,0} \gets g_{1}^{\alpha_{i,0}}\cdot (g^{a})^{-\ID^{*}_{i}\alpha_{i,1}} \qquad u_{i,1} \gets (g^{a})^{\alpha_{i,1}} \qquad \mbox{ for } 1\leq i\leq L
    \end{array}
    \end{displaymath}
\item $\B$ runs $\A$ on the public parameters $(g_{1},g_{2},u_{0,0},u_{0,1},\ldots,u_{L,0},u_{L,1})$. If $\A$ makes an oracle queries, then $\B$ answers queries as follows:
    \begin{itemize}
    \item $\texttt{CreateTA}(\TA)$: If $\TA\in \TA^{*}$ then $\B$ returns $\mpk_{\TA}$. If $\TA\notin \TA^{*}$ then $\B$ generates $\beta_{\TA}\getsr \Zbb_{p}$ and returns $g_{1}^{\beta_{\TA}}$.
    \item $\texttt{CorruptTA}(\TA)$: For this query to be valid, we have $\TA \notin \TA^{*}$; hence, $\B$ returns $g_{2}^{\beta_{\TA}}$.
    \item $\texttt{SetupCoalitionBroadcast}(\TA,(\TA_{1},\ldots,\TA_{n}))$: For this to be a valid request, we must have $\TA\notin \{\TA_{1},\ldots,\TA_{n}\}$. For $\TA \neq \TA^{*}_{1}$, $\B$ can compute the private key directly; hence, $\B$ can return the correct value using the appropriate algorithm. For $\TA=\TA^{*}_{1}$, $\B$ generates $r_{0}\getsr \Zbb_{p}$ and computes
        \begin{eqnarray*}
        w_{i,0} &\gets& g_{2}^{\frac{-\alpha_{0,0}}{\alpha_{0,1}(\TA_{i}-\TA^{*}_{1})}} \cdot g_{2}^{\sum_{j=2}^{n^{*}}\beta_{j}} \cdot \Big( u_{0,0} \cdot u_{0,1}^{\TA_{i}} \Big)^{r_{0}}\\
        w_{i,1} &\gets& g_{2}^{-\frac{1}{\alpha_{0,1}(\TA_{i}-\TA^{*}_{1})}}g_{1}^{r_{0}}
        \end{eqnarray*}
        for $1\leq i\leq n$ and sets $w_{i}\gets (w_{i,0},w_{i,1})$. $\B$ outputs a list of TA/message pairs $((\TA_{i},w_{i}))_{i=1}^{n}$.
    \item $\texttt{CorruptUser}(\TA,\vec{\ID})$: For this to be a valid query, we require that $\TA\neq \TA^{*}_{1}$ or $\vec{\ID}$ is not ancestor of $\vec{\ID^{*}}$ where $\vec{\ID}=(\ID_{1},\ldots,\ID_{\ell})$. If $\TA\neq \TA^{*}_{1}$ then we may extract a decryption key using the extract algorithm and the master secret key of $\TA$. If $\TA=\TA^{*}_{1}$ and there must exist an index $1\leq j\leq L$ such that $\ID_{j} = \ID^{*}_{j}$, then $\B$ generates $r_{0},\ldots,r_{\ell}\getsr \Zbb_{p}$ and computes the decryption key $(h,a_{0},\ldots,a_{j})$ for $(\ID_{1},\ldots,\ID_{j})$ as
        \begin{eqnarray*}
        h &\gets& g_{2}^{\frac{-\alpha_{j,0}}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}} \cdot g_{2}^{\sum_{j=2}^{n^{*}}\beta_{j}}\cdot \Big(u_{0,0}\cdot u_{0,1}^{\TA}\Big)^{r_{0}} \cdot \prod_{i=1}^{j} \Big(u_{i,0}\cdot u_{i,1}^{\ID_{i}}\Big)^{r_{i}}\\
        a_{i} &\gets& g_{1}^{r_{i}} \mbox{ for } 0\leq i\leq j-1\\
        a_{j} &\gets& g_{2}^{-\frac{1}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}} \cdot g_{1}^{r_{j}}
        \end{eqnarray*}
        $\B$ computes the decryption key for $\vec{\ID}$ using the key derivation algorithm and returns the result. If no such $j$ exists then $\B$ aborts.
    \item $\texttt{Test}(m_{0},m_{1})$: For this query to be valid, we require that $|m_{0}|=|m_{1}|$. $\B$ chooses a random bit $b\getsr \{0,1\}$ and computes the ciphertext 
        \begin{displaymath}
        C^{*} \gets (g^{c},(g^{c})^{\alpha_{1,0}}, \ldots, (g^{c})^{\alpha_{\ell^{*},0}}, m_{b}\cdot Z) \, .
        \end{displaymath}
        $\B$ returns the ciphertext $C^{*}$.
    \end{itemize}
    $\A$ terminates with the output of a bit $b'$.
\item If $b=b'$ then $\B$ outputs 1. Otherwise, outputs 0.
\end{enumerate}

The $\texttt{CorruptUser}$ oracle works perfectly providing that $\B$ does not abort. The simulator only occurs if $\vec{\ID^{*}}\neq \vec{\ID}$, $\vec{\ID^{*}}$ is an ancestor of $\vec{\ID}$, and $\vec{\ID}$ is an ancestor of $(\ID^{*}_{1},\ldots,\ID^{*}_{L})$. In particular, this means that $\ID_{\ell^{*}+1} = \ID^{*}_{\ell^{*}+1}$, which occurs with probability $1/p$ as this value is information theoretically hidden from $\A$. Hence, the probability that this does not occur in the entire execution of $\A$ is $q_{K}/p$ where $q_{K}$ is the number of queries to the $\texttt{CorruptUser}$ oracle. To show that if the simulator doesn't abort, the $\texttt{CorruptUser}$ returns a correct key, not that it suffices to show that 
\begin{displaymath}
\msk_{\TA^{*}_{1}} \Big(u_{j,0}\cdot u_{j,1}^{\ID_{j}}\Big)^{r} = g_{2}^{\frac{-\alpha_{j,0}}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}} \cdot g_{2}^{-\sum_{i=2}^{n^{*}} \beta_{i}} \qquad \mbox{ for } \qquad r = -\frac{b}{\alpha_{0,1}(\ID_{j}-\ID^{*}_{j})}\, .
\end{displaymath}
We note that $\msk_{\TA^{*}_{1}} = g_{2}^{a-\sum_{i=2}^{n^{*}} \beta_{i}}$. The correct decryption key is
\begin{eqnarray*}
\msk_{\TA^{*}_{1}} \Big(u_{j,0}\cdot u_{j,1}^{\ID_{j}}\Big)^{r} &=& g_{2}^{a-\sum_{i=2}^{n^{*}} \beta_{i}} \Big( g^{\alpha_{j,0}} \cdot (g^{a})^{-\alpha_{j,1}\ID^{*}_{j}} \cdot (g^{a})^{\alpha_{j,1}\ID_{j}} \big)^{-\frac{b}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}}\\
&=& g^{ab} g_{2}^{-\sum_{i=2}^{n^{*}}\beta_{i}} \Big( g^{\alpha_{j,0}} \cdot (g^{a})^{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})} \Big)^{-\frac{b}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}} 
\\
&=& g^{ab} g_{2}^{-\sum_{i=2}^{n^{*}}\beta_{i}} (g^{b})^{\frac{-\alpha_{j,0}}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}}g^{-ab}\\
&=& g_{2}^{\frac{-\alpha_{j,0}}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}} g_{2}^{-\sum_{i=2}^{n^{*}}\beta_{i}}\\
\end{eqnarray*}
Hence, $\B$'s simulation returns a correct decryption key. A similar calculation shows that the $\texttt{SetupCoalitionBroadcast}$ algorithm gives correct broadcast messages for $\TA^{*}_{1}$. All other oracles that $\B$ provides (except, perhaps, the $\texttt{Test}$ oracle) correctly simulate the security model for $\A$.

If $Z=e(g,g)^{abc}$ then the $\texttt{Test}$ oracle provides a correct encryption of $m_{b}$. This is because an encryption using the random value $c$ would have 
\begin{eqnarray*}
C_{1} &=& g_{1}^{c}=g^{c}\\
C_{2,0} &=& (u_{0,0} \cdot u_{0,1}^{\TA^{*}_{1}})^{c} = (g^{\alpha_{0,0}})^{c} = (g^{c})^{\alpha_{0,0}}\\
C_{2,i} &=& (u_{i,0} \cdot u_{i,1}^{\ID^{*}_{i}})^{c} = (g^{c})^{\alpha_{i,0}} \qquad \mbox{ for } 1\leq i\leq \ell^{*}\\
C_{3} &=& m_{b} \cdot e(\prod_{i=1}^{n^{*}} \mpk_{\TA_{i}},g_{2})^{c}
= m_{b} \cdot e(g^{a},g^{b})^{c} = m_{b} \cdot e(g,g)^{abc}
\end{eqnarray*}
The probability that $\B$ outputs 1 in this situation is the probability that $b=b'$ in the mTA-IND-WID-CPA game for the attacker $\A$. If $Z$ is random then the $\texttt{Test}$ oracle information theoretically hides $b$ and so the probability that $\B$ outputs 1 in this situation is $1/2$. Hence, the probability that $\B$ wins the DBDH is $\epsilon-q_{K}/p$. \qed

\section{Still to be done}

\begin{itemize}
\item This whole treatment ignores the update coalition protocols.
\item The use of ROM to turn selective-identity into non-selective identity should be proven.
\item CHK transform.
\item Can we use the same techniques to prove the security of a multiple TA BBG-WIBE and a multiple TA Waters-WIBE? Can we do it for some general treatment? The Waters version would be particular good as it provides CPA security in the non-selective-identity model.
\item What about the Gentry-Halevi HIBE?
\item What about the other things on the list, especially node-to-node coalitions?
\end{itemize}

\bibliographystyle{plain}
\bibliography{../../Master}
\end{document}
