\documentclass[10pt]{llncs}
%\documentclass[10pt]{article}

\usepackage{fullpage}
\usepackage{amsmath,amssymb}
\usepackage{verbatim}

\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\U}{\mathcal{U}}

\newcommand{\Zbb}{\mathbb{Z}}
\newcommand{\Gbb}{\mathbb{G}}

\newcommand{\ID}{\mathit{ID}}
\newcommand{\TA}{\mathit{TA}}

\newcommand{\pk}{\mathit{pk}}
\newcommand{\sk}{\mathit{sk}}

\newcommand{\getsr}{\stackrel{{\scriptscriptstyle\$}}{\gets}}
\newcommand{\adv}[2]{\mathit{Adv}_{#1}^{\texttt{#2}}}

\title{Multiple Hierarchy Wildcard Encryption}
\author{Christopher A. Seaman\inst{1} \and
		Kent D. Boklan\inst{2} \and
		Alexander W. Dent\inst{3}}

\institute{Graduate Center, City University of New York, USA \and
			Queens College, City University of New York, USA \and
			Royal Holloway, University of London, UK}

\begin{document}
\maketitle

%\begin{abstract}
%\end{abstract}

\section{Introduction and Motivation}
\subsection{Identity-Based Encryption}
%FIXME: What is IBE, advantage over PKI.

Identity-based encryption is most often considered in the context of one-to-one communication within a single Trusted Authority (TA); every encrypted message is sent between two individual entities.  In this paper we consider a coalition of TA's desiring secure one-to-many communication, with each TA retaining the security of its secret keys.  This secrecy requirement is natural in the setting of dynamic coalitions.

\subsection{Known Extensions}
%FIXME: HIBE

	One-to-many secure communication is a powerful cryptographic tool.  Take a MANETs setting for example, where transmission is much more expensive than computation, one-to-many communication allows for a single transmitted message to be read by any number of valid recipients within range.  Multiple recipients may decrypt the same message through the use of one or more `wildcards'. A wildcard is a special character, commonly `*', that may be used in an address in lieu of specifying a particular aspect of an identity. Anyone with an identifier matching the non-wildcard portion is then able to read the message.
	
	The method of employing wildcards into hierarchical identity-based encryption structures (Abdallah et al., 2006) allows an individual at any level within one TA to send messages to entire levels within that TA.
%FIXME: To military structure, details	
%	  The hierarchy of a TA could be as simple as an email address, every entity under the TA (say ``school.edu'') has a name. Considered as an IBE setting, one might desire to send a single message to an address of the form ``name@school.edu'', but a message pertaining to everyone at the school might be better sent to ``*@school.edu'' in a wildcard IBE setting. A message addressed to the leadership of universities could be sent to ``provost@*.edu'' or a message for computer system administrators might be addresses ``sysadmin@*.*''.

	The wildcard method of multicast communication is limited by the structure of the hierarchy: it cannot distinguish between entities within a single hierarchical level.  For example, a single message to ``*@school.edu'' could be read by ``alice@school.edu'', ``bob@school.edu'', and ``eve@school.edu''; however, it would not be possible to send a single message to Alice and Bob without also allowing Eve to read it. Likewise, a message may be addressed to a single specified TA or to all TA's by wildcard; it is impossible to select multiple TA's to receive a message without making the message readable across all TA's. It is interesting to note that a message may be broadcast to all TA's in a coalition and remain secure against non-members of the coalition.
	%FIXME: example on communication problem

\subsection{Our Contributions}
%FIXME: structure: mTA-WIBE -> coalition -> dynamic reconfiguration

	In addition to one-to-many communication, this paper assumes that the coalition of TA's may change over time and allows those changes without compromising the security of communication or any TA's secret key.  TA's may be removed or added to the coalition with minimal configuration.  Upon a change in coalition make-up the participating TA's exchange public information, and based on non-public secret information they are able to communicate.  The private keys of subordinate entities of each TA must be updated, but each TA can accomplish this through a single broadcast message exclusively readable to members of that TA.  This flexible reconfiguration ability similarly allows a fixed set of TA's in coalition to schedule secure reconfigurations with minimal communication long before any secret key has a chance to become stale or compromised.
	
	Should the members of the coalition of TA's change at some point, an interesting aspect of this system is that it is quickly reconfigurable.  Reconfiguration of the system in play relies on the hierarchical organization of secret keys, the ability to broadcast messages to all members of a TA.  In our example instantiation based on the Boneh-Boyen HIBE as extended by Abdalla et al. we rely only on the security assumptions initially made by Boneh and Boyen, the difficulty of the Bilinear Decision Diffie-Hellman (BDDH) problem.

	Reconfiguring keys to adapt to changing coalitions is made more efficient through  one-to-many communication that is non-confidential, but integrity protected. Coalition member TA's conduct a round of communication at the highest level to create TA-specific key adjustment parameters. Then each TA securely broadcasts this information to all of its subordinates in a single message in lieu of sending a separate message to each subordinate with their unique private key.

\subsection{Usage Scenario}

As an example of our techniques, we propose the following highly simplistic usage scenario. We suppose that individuals in a force can be identified using the hierarchical identifier (force name, mission name, individual name). For example, an individual could be identified as (US force, Mission 12, John Smith). Our scheme allows an architecture in which a central facility for each force generates a master key-pair. The master public key is publicly distributed and is intended for long-term use. We will assume that all master public keys are known by all individuals in the scenario. The master private key is used by the central facility to derive keys for each hierarchical name (force name, mission name, individual name).

These individual hierarchical encryption schemes can be used as independent WIBEs. In other words, any user in possession of a force's master public key and a hierarchical identifier (force name, mission name, individual name) may send a message that can only be read by that individual. Furthermore, the hierarchical identifier may include wildcard characters, denoted *. So, for example, a user could send a message to every individual on a mission using the hierarchical identifier (force name, mission name, *) or to an individual on any mission using the hierarchical identifier (force name, *, individual name).

However, our scheme allows coalitions to be formed between forces. If two (or more) forces which to form a coalition, then the central facilities exchange some (public) information which then allow the central facility to send a broadcast message to every member of the force. This broadcast message allows the individuals to derive coalition decryption keys from their individual decryption keys. The individuals must be assured that the broadcast message is from their force's central facility, but the message is short and need not be confidential. These coalition keys allow individuals to decrypt messages sent to multiple forces simultaneously.

For example, for a particular mission, the US and UK force may form a coalition. This allows messages to be sent to hierarchical identifiers of the form (coalition name, mission name, individual name) where the coalition name is consists of both the US and UK forces. Therefore, to send a message to all individuals involved in the mission, one would merely have to send the message using the hierarchical name (US and UK force, mission name, *). This message could only be decrypted by an individual on the mission who has received the (public) broadcast update from their central facility which allows them to form the coalition key for the coalition containing the US forces and the UK forces.

Furthermore, these coalitions can be dynamic in nature. So, in the above scenario, if the German force was later included in the mission, then broadcast messages could be sent to update coalition decryption keys to allow the US, UK, and German forces to decrypt messages. The German force members would not be able to read earlier messages, which were encrypted for use the US and UK forces coalition only. If the US force retired from the mission, then the coalition keys could be updated so that only the UK and German forces could decrypt messages.
	
\section{Syntax}

We define a Trusted Authority ($\TA_i$) as a hierarchy of identities of the form $\vec{\ID} = (\ID_1, \ID_2, ..., \ID_k)$ with the same first identity ($\ID_1 = \TA_i$) and maximum depth of $k \le \ell$. Given a population of $\TA$'s $\U = \{\TA_1, \TA_2, ..., \TA_n\}$ we define a coalition $\C = \{\TA_a, \TA_b, ..., \TA_k\} \subseteq \U$. A multi-hierarchy WIBE consists of the following PPT algorithms/protocols:

\begin{itemize}

\item $\texttt{CreateTA}(\TA_i)$: This algorithm is run once by $\TA_i$, it generates a public key and private key for that TA $(pk_i,sk_i)\getsr \texttt{CreateTA}$ and publishes $\pk_i$.
\medskip

\item $\texttt{SetupCoalitionBroadcast}(\TA_i,sk_{i},(\TA_j,pk_j) \forall \TA_j \in \C)$: This algorithm calculates messages $w_{i,j}$ to be distributed from $\TA_i$ to each $\TA_j \in \C \setminus \{\TA_i\}$ who haven't received messages from previous instantiations of the algorithm. These values are stored by $\TA_j$ for later use in the \texttt{SetupCoalitionKeys} algorithm.
\medskip

\item $\texttt{SetupCoalitionKeys}(\TA_j,sk_j,(\TA_i,w_{i,j}) \forall \TA_j \in \C)$: The algorithm completes the setup of the coalition. After every member $\TA_{i}$ of the coalition has provided a message $w_{i,j}$ to $\TA_j$. It outputs a message $v_j$ to be broadcast to every member of $\TA_j$'s hierarchy in order who then run the \texttt{ExtractCoalitionKey} algorithm to obtain their $\C$ rcoalition-specific secret keys.

%\item $\texttt{RefreshCoalitionBroadcast}(\TA_i, sk_i,(\TA_j,pk_j) \forall \TA_j \in \C')$: Allows $\TA_i$ to refresh it's key broadcast messages $w_{i,j}$. $\TA_i$ runs \texttt{SetupCoalitionBroadcast} for the coalition $\C'$ outputing new messages $w_{i,j}'$. For the refresh to take effect, each $\TA$ must then run \texttt{UpdateCoalitionKeys}.

\end{itemize}

The system should be able to dynamically update the coalition. We may wish to change from a coalition $\C$ to a coalition $\C'$. Persistent members of $\C \cap \C'$ execute the $\texttt{SetupCoalitionBroadcast}$ algorithm to broadcast messages to new members of $\C' \setminus \C$. New members also run $\texttt{JoinCoalition}$, but broadcast messages to all members of coalition $\C'$. Excluded members $\C'\setminus \C$ are excluded and left unable to communicate under the new coalition.

We now describe the algorithms required by the individual users.

\begin{itemize}
\item $\texttt{Extract}(\vec{ID},\ID',d_{\vec{\ID}})$: This algorithm outputs a decryption key $d_{\vec{\ID}\|\ID'}$ for the identity $\vec{\ID} \| \ID'$. The basic level has $\vec{\ID}=\TA_i$ and $d_{\TA_i}= sk_i$.
\medskip

\item $\texttt{ExtractCoalitionKey}(\vec{\ID} \in \TA_i, v_i, d_{\vec{\ID}})$: This algorithm outputs a user key $c_{\vec{\ID}}$ for the coalition $\C$ by combining the broadcast message $u_i$ corresponding to coalition $\C$ and their decryption key $d_{\vec{\ID}}$.
\medskip

\item $\texttt{UpdateCoalitionKey}(\vec{\ID} \in \TA_i, u_i , c_{\vec{\ID}}, d_{\vec{\ID}})$: This algorithm outputs an updated user key $c'_{\vec{\ID}}$ for the coalition $\C'$ by combining the broadcast key $u_i$ corresponding to coalition $\C'$ with the user's decryption key $d_{\vec{\ID}}$ and existing coalition key $c_{\vec{\ID}}$ corresponding to the previous coalition $\C$.
\medskip

\item $\texttt{Encrypt}(\mathit{P}, m, (\TA_i,pk_i) \forall \TA_i \in \C)$: This algorithm is used to encrypt a message $m$ to entities satisfying the pattern $\mathit{P}$ under the coalition $\C = \{\TA_a,\ldots,\TA_k\}$. It outputs a ciphertext $C$ or the invalid symbol $\perp$.
\medskip

\item $\texttt{Decrypt}(\vec{\ID}, c_{\vec{\ID}}, d_{\vec{\ID}}, C, (\TA_i,pk_i) \forall \TA_i \in \C)$: Decrypts ciphertext $C$ to output message $m$.
\end{itemize}

\begin{comment}
\section{Security Model}

The security model is parameterized by a bit $b$ involves a PPT attacker $\A$ which is initially given the input $1^k$ and access to the following oracles:
\begin{itemize}
\item $\texttt{CreateTA}(\TA)$: The oracle computes $(pk_i,sk_i)\getsr \texttt{Setup}(1^{k},\TA)$ for the TA identity $\TA_i$ and returns $pk_i$. This oracle can only be queried once for each identity $\TA_i$.
\medskip

\item $\texttt{SetupCoalitionBroadcast}(\TA_i,\C)$: This oracle runs the $\texttt{SetupCoalitionBroadcast}$ algorithm for coalition $\C$ containing $\TA_i$ and returns messages $w_{i,j} \forall \TA_j \in \C \setminus \TA_i$.
\medskip

\item $\texttt{SetupCoalitionKeys}(\TA_i, w_{j,i}\forall \TA_j \in \C \setminus \TA_i)$: This oracle can only be queried if each $\TA_i, \TA_j \in \C$ has been queried to the $\texttt{SetupCoalitionBroadcast}$ oracle with $k$ $\TA$'s in the coalition. The oracles runs the $\texttt{SetupCoalitionKeys}$ algorithm assuming that message $w_{j,i}$ was sent by $\TA_{j}$. Note that this does not imply that all the TAs believe that they're in the same coalition.
\medskip

\item $\texttt{Corrupt}(\vec{\ID})$: The oracle returns $d_{\vec{\ID}}$ for the identity $\vec{\ID}$.  Note that if $\vec{\ID} = TA_i$ then this method returns $\TA_i$'s secret key $sk_i$ and records $\TA_i$ is corrupt.
\medskip

\item $\texttt{UserDecrypt}(\vec{\ID},C^{*})$: This oracle decrypts the ciphertext with the decryption key $d_{\vec{\ID}}$.
\medskip

\item $\texttt{CoalitionDecrypt}(\C,\vec{\ID},C^{*})$: This oracle decrypts the ciphertext with the coalition decryption key $c_{\vec{\ID}}$ corresponding to coalition $\C$.
\medskip

\item $\texttt{Test}(\C^*,\mathit{P},m_{0},m_{1})$: This oracle takes as input two messages $(m_{0},m_{1})$ of equal length. It encrypts the message $m_{b}$ for the coalition using $pk_i \forall \TA_i \in \C^*$ under the pattern $\mathit{P}$. This oracle may only be access once and outputs a ciphertext $C^{*}$. We will let $\C^*$ denote the challenge coalition $(\TA_{a},\ldots,\TA_{k})$.
\end{itemize}
The attacker terminates by outputting a bit $b'$. The attacker's advantage is defined to be:

\begin{eqnarray*}
	& \adv{\A}{IND}(k) = |Pr[b'=1|b=1]-Pr[b'=1|b=0]|
\end{eqnarray*}

The disallowed oracle queries:
\begin{enumerate}
	\item A \texttt{Corrupt} query for any $\vec{\ID}$ in the test coalition matching pattern $\mathit{P}$
	\item A \texttt{Corrupt} query for any $\vec{\ID}$ in the test coalition that is an ancestor of pattern $\mathit{P}$, i.e. there exists $\vec{\ID}^*$ such that $\vec{\ID}\|\vec{\ID}^*$ matches the pattern $\mathit{P}$ %under an authority $\TA$ in the test coalition if there has been a \texttt{SetupCoalitionKeys} or \texttt{UpdateCoalitionKeys} query for the test coalition
	\item A \texttt{UserDecrypt} decrypt query for $C^{*}$ and any user $\ID$ in the test coalition matching the pattern $\mathit{P}$ %under an authority $\TA$ in the test coalition if there has been a \texttt{SetupCoalitionKeys} or \texttt{UpdateCoalitionKeys} query for the test coalition.
\end{enumerate}
\end{comment}

\section{Security Model}
%FIXME - Define: BDDH

The security of a multi-TA WIBE is parametrized by a bit $b \in \{0,1\}$ and a positive integer $k$ through the following game. An attacker, $\A$, is tasked with guessing the value of $b$ chosen by the challenger. Initially an attacker is given the public parameters for the system. These parameters include $(g_1,$ $g_2,$ $u_{1,0},$ $u_{1,1},$ $u_{2,0},$ $u_{2,1},$ $\ldots,$ $u_{L,0},$ $u_{L,1}) \in \Gbb$ defining a scheme of maximum depth $L$, an identity space $\mathcal{ID} = \{0,1\}^k$, and a bilinear map $e: \Gbb \times \Gbb \rightarrow \Gbb^*$. In the first phase the attacker is allowed to query the challenger. For chosen-plaintext security (IND-ID-CPA), the attacker is given polynomially many queries to the following oracles:

\begin{itemize}
\item $\texttt{CreateTA}(\TA)$: The oracle computes $(pk_i,sk_i)\getsr \texttt{Setup}(1^{k},\TA)$ for the TA identity $\TA_i$ and returns $pk_i$. This oracle can only be queried once for each identity $\TA_i$.
\medskip

\item $\texttt{SetupCoalitionBroadcast}(\TA_i,\C)$: This oracle runs the $\texttt{SetupCoalitionBroadcast}$ algorithm for coalition $\C$ containing $\TA_i$ and returns messages $w_{i,j} \forall \TA_j \in \C \setminus \TA_i$.
\medskip

\item $\texttt{SetupCoalitionKeys}(\TA_i, w_{j,i}\forall \TA_j \in \C \setminus \TA_i)$: This oracle can only be queried if each $\TA_i, \TA_j \in \C$ has been queried to the $\texttt{SetupCoalitionBroadcast}$ oracle with $k$ $\TA$'s in the coalition. The oracles runs the $\texttt{SetupCoalitionKeys}$ algorithm assuming that message $w_{j,i}$ was sent by $\TA_{j}$. Note that this does not imply that all the TAs believe that they're in the same coalition.
\medskip

\item $\texttt{Corrupt}(\vec{\ID})$: The oracle returns $d_{\vec{\ID}}$ for the identity $\vec{\ID}$.  Note that if $\vec{\ID} = TA_i$ then this method returns $\TA_i$'s secret key $sk_i$.
\end{itemize}

For chosen-ciphertext security, the attacker is additionally given access to decryption oracles:

\begin{itemize}
	\item $\texttt{UserDecrypt}(\vec{\ID},C^{*})$: This oracle decrypts the ciphertext with the decryption key $d_{\vec{\ID}}$.
	\medskip

	\item $\texttt{CoalitionDecrypt}(\C,\vec{\ID},C^{*})$: This oracle decrypts the ciphertext with the coalition decryption key $c_{\vec{\ID}}$ corresponding to coalition $\C$.
\end{itemize}

To end the first phase the attacker outputs two equal-length messages $m_1, m_2$ and a challenge pattern $\vec{\mathit{P}}^ = (P_1, P_2, \ldots, P_\ell)*$ for $P_i \in \mathcal{ID} \cup \{*\}$. This is modeled as a single query to the oracle:

\begin{itemize}
\item $\texttt{Test}(\C^*,\mathit{P},m_{0},m_{1})$: This oracle takes as input two messages $(m_{0},m_{1})$ of equal length. It encrypts the message $m_{b}$ for the coalition using $pk_i \forall \TA_i \in \C^*$ under the pattern $\mathit{P}$. This oracle may only be access once and outputs a ciphertext $C^{*}$. We will let $\C^*$ denote the challenge coalition $(\TA_{a},\ldots,\TA_{k})$.
\end{itemize}

The relationship between the attacker's queries and choice of $\vec{P}^*$ are restricted. Specifically, the attacker is not allowed access to the decryption keys of nodes matching the challenge pattern nor nodes capable of generating those keys. The disallowed oracle queries are:
\begin{enumerate}
	\item A \texttt{Corrupt} query for any $\vec{\ID}$ matching pattern $\mathit{P}$
	\item A \texttt{Corrupt} query for any $\vec{\ID}$ that is an ancestor of pattern $\mathit{P}$, i.e. there exists $\vec{\ID}^*$ such that $\vec{\ID}\|\vec{\ID}^*$ matches the pattern $\mathit{P}$
	\item A \texttt{UserDecrypt} decrypt query for $C^{*}$ and any user $\ID$ in the test coalition matching the pattern $\mathit{P}$ or an ancestor thereof.
\end{enumerate}

For the second phase the attacker is once again given access to the queries from the first phase (still restricted as above). The attacker ends the game by outputting a bit $b'$ as its guess for the value of bit $b$. We define the attacker's advantage as:

\begin{eqnarray*}
	& \adv{\A}{IND}(k) = |Pr[b' = b] - \frac{1}{2}|
\end{eqnarray*}

\section{BB-Based Construction}

We may instantiate this notion using the Boneh-Boyen WIBE. We assume that there exists a set of bilinear map groups $G, G_{T}$ of large prime order $p$ and a bilinear map $e: G \times G \rightarrow G_{T}$. We assume the existence of two randomly chosen generators $g_{1},g_{2}\getsr G^{*}$. We also assume that there exist $2L+2$ randomly chosen group elements $u_{i,j} \getsr G_{2}$ where $i\in \{0,1,2,\ldots,L\}$ and $j\in \{0,1\}$ and $L$ is a limit on the maximum depth in a hierarchy. The MTA-WIBE is described as follows:

\begin{itemize}
\item $\texttt{CreateTA}(\TA_i)$: The TA generates $\alpha_i \getsr \Zbb_{p}$ and computes master public key $pk_i \gets g_{1}^{\alpha_i}$. The master private key is defined to be $g_{2}^{\alpha_i}$.\medskip

\item $\texttt{Extract}(\vec{ID},\ID',d_{\vec{\ID}})$: Under $\TA_i = \ID_1$, the first level identity is $\vec{\ID}=(\ID_1, \ID_2)$. The TA generates $r_1,r_2\getsr \Zbb_{p}$ and computes the key $d_{\vec{\ID}} = (h,a_{1},a_{2})$ where $h\gets g_{2}^{\alpha_i}(u_{0,0} \cdot u_{0,1}^{\ID_1})^{r_1}(u_{1,0} \cdot u_{1,1}^{\ID_2})^{r_{2}}$, $a_{1}\gets g_{1}^{r_{1}}$ and $a_{2} \gets g_{1}^{r_{2}}$. An identity $(\ID_{1},\ldots,\ID_{\ell})$ with private key $(h,a_{1},a_{2},\ldots,a_{\ell})$ and $\ell < L$ can compute the decryption key for its child $(\ID_{1},\ldots,\ID_{\ell},\ID_{\ell+1})$ by choosing a random value $r_{\ell+1}$ and computing the private key as the tuple $(h',a_{0},a_{1},\ldots,a_{\ell},a_{\ell+1})$ where $h' \gets h(u_{\ell+1,0}\cdot u_{\ell+1,1}^{\ID_{\ell+1}})^{r_{\ell+1}}$ and $a_{\ell+1}\gets g_{1}^{r_{\ell+1}}$.\medskip

\item $\texttt{SetupCoalitionBroadcast}(\TA_i, \C)$: For $\TA_j \in \C$, $\TA_i$ randomly generates $r_{j}\getsr \Zbb_{p}$ and computes $w_{i,j,0} \gets g_{2}^{\alpha_i}(u_{0,0} \cdot u_{0,1}^{\TA_{j}})^{r_{j}}$ and $w_{i,j,1} \gets g_{1}^{r_{j}}$ where $\TA_{j} \in \Zbb_{p}$ is the identity of $\TA_{j}$. The algorithm sets $w_{i,j}=(w_{i,j,0},w_{i,j,1})$ and outputs a list of TA/message pairs $(\TA_{j},w_{i,j})\forall \TA_j \in \C \setminus \TA_i$.\medskip

\item $\texttt{SetupCoalitionKeys}(\TA_i,sk_i,(\TA_j, pk_j, w_{j,i}) \forall \TA_j \in \C)$: The algorithm outputs the message $u_i$ $\gets$ $(\prod w_{j,i,0}, \prod w_{j,i,1}) \forall \TA_j \in \C \setminus \TA_i$ \medskip

\item $\texttt{ExtractCoalitionKey}(\C,u_i,d_{\vec{\ID}})$: Parse $u_i$ as $(w_{j,i})$ where $w_{j,i,0} = g_{2}^{\alpha_{j}}(u_{0,0} \cdot u_{0,1}^{\TA})^{r_{j}}$ and $w_{j,i,1} = g_{1}^{r_{j}}$ (where $g_{2}^{\alpha_{j}}$ is the private key of $\TA_{j}$). A user with private key $(h,a_{0},a_{1},a_{2},\ldots,a_{\ell})$ can form a coalition key $(h',a'_{0},a_{1},a_{2},\ldots,a_{\ell})$ where
\begin{eqnarray*}
	h' & \gets & h \prod_{j=1}^{k} w_{j,0} = g_{2}^{\sum \alpha_{j}}(u_{0,0} \cdot u_{0,1}^{\TA})^{\sum r_{j}} \\
	a'_{0} & \gets & a_{0} \prod_{j=1}^{k} w_{j,1} = g_{1}^{r+\sum r_{j}}
\end{eqnarray*}

\item $\texttt{Encrypt}(\mathit{P},m, (\TA_i, pk_i) \forall \TA_i \in \C)$: Let $\ell$ be the depth of the pattern and $W(P)$ be the set of levels which have wildcard characters. The sender chooses $t\getsr \Zbb_{p}$ and computes the ciphertext $C=(C_{1},C_{2,0},C_{2,1},...,C_{2,\ell},C_{3})$ where
\begin{eqnarray*}
	C_{1} & \gets & g_{1}^{t} \\
%	C_{2,0} & \gets & (u_{0,0}\cdot \prod_{i=1}^{n} u_{0,1}^{\TA_{i}})^{t}\\
	C_{2,i} & \gets & \left\{
		\begin{array}{ll}
			(u_{i,0} \cdot u_{i,1}^{\ID_{i}})^{t} & \qquad \mbox{if } i \notin W(P) \\
			(u_{i,0}^{t},u_{i,1}^{t}) & \qquad \mbox{if } i \in W(P)
		\end{array}
	\right. \\
	C_{3} &\gets& m \cdot e(\prod_{j=1}^{n} pk_j,g_{2})^{t}
\end{eqnarray*}

\item $\texttt{Decrypt}(\vec{\ID},c_{\vec{\ID}},C)$: Parse $\vec{\ID}$ as $(\ID_{1},\ldots,\ID_{\ell})$, $c_{\ID}$ as $(h,a_{0},\ldots,a_{\ell})$, and $C$ as $(C_{1},C_{2,0},\ldots,C_{2,\ell},C_{3})$. For each $i\in W(P)$, parse $C_{2,i}$ as $(v_{i,0},v_{i,1})$. We recover a complete HIBE ciphertext by setting $C'_{2,i} \gets C_{2,i}$ if $i\notin W(P)$, and $C_{2,i}\gets v_{i,0} \cdot v_{i,1}^{\ID_{i}}$ if $i\in W(P)$. Recover
\begin{eqnarray*}
	m' & \gets & C_{3} \frac{\prod_{i=0}^{\ell} e(a_{i},C'_{2,i})}{e(C_{1},h)}
\end{eqnarray*}

and return $m'$.
\end{itemize}

A HIBE scheme may be designed analogously except that we remove the possibility of the pattern containing wildcards.

\begin{theorem}
Suppose that there exists an attacker $\A$ against the selective-identity multiple TA Boneh-Boyen WIBE that runs in time $t$ and with advantage $\epsilon$, then there exists an attacker $\B$ against the selective-identity multiple TA Boneh-Boyen HIBE that runs in time $t'$ and with advantage $\epsilon'$ where $t \approx t'$ and $\epsilon' = \epsilon$.
\end{theorem}
\emph{Proof} We directly describe the algorithm $\B$ which breaks the HIBE using the algorithm $\A$ as a subroutine. The algorithm $\B$ runs as follows:
\begin{enumerate}
\item $\B$ runs $\A$ on the security parameter. $\A$ responds by outputting a description of the challenge coalition $\TA^{*} = (\TA^{*}_{1},\ldots,\TA^{*}_{n})$ and the challenge pattern $P^{*} = (P^{*}_{1},\ldots,P^{*}_{\ell^{*}})$. Let $\pi$ be a map which identifies the number of non-wildcard entries in the first $i$ layers of $P^{*}$, i.e. $\pi(i) = i - |W(P^{*}_{\leq i})|$. $\B$ outputs the challenge coalition $\TA^{*}$ and the challenge identity $\hat{\ID}^{*}=(\hat{\ID}^{*}_{1},\ldots,\hat{\ID}^{*}_{\pi(\ell^{*})})$ where $\hat{\ID}^{*}_{i} = P^{*}_{\pi(i)}$.
\item The challenger responds with HIBE parameters $\mathit{param} = (\hat{g}_{1},\hat{g}_{2},\hat{u}_{0,0},\ldots,\hat{u}_{L,1})$. $\B$ generates WIBE parameters as follows:
	\begin{displaymath}
	\begin{array}{rcll}
	(g_{1},g_{2}) &\gets& (\hat{g}_{1},\hat{g}_{2})&\\
	u_{i,j} &\gets& \hat{u}_{\pi(i),j} &\mbox{ for } i\notin W(P^{*}), j\in\{0,1\}\\
	u_{i,j} &\gets& g_{1}^{\beta_{i,j}} &\mbox{ for } i\in W(P^{*}), j\in\{0,1\}\mbox{ where } \beta_{i,j}\getsr \mathbb{Z}_{p}\\
	u_{i,j} &\gets& \hat{u}_{i-|W(P^{*})|,j} &\mbox{ for } i\in \{\ell+1,\ldots,L\}, j\in\{0,1\}
	\end{array}
	\end{displaymath}
\item $\B$ executes $\A$ on the public parameters $(g_{1},g_{2},u_{0,0},\ldots,u_{L,1})$. $\A$ may make the following oracle queries:
	\begin{itemize}
	\item \texttt{CreateTA}: $\B$ forwards this request to its own oracle and returns the response.
	\item \texttt{Corrupt}: $\B$ forwards this request to its own oracle and returns the response. Note that the disallowed queries for this oracle are preserved by the map $\ID_i \rightarrow \ID_{\pi(i)}$.
	\item \texttt{SetupCoalitionBroadcast}: $\B$ forwards this request to its own oracle and returns the response.
	\item \texttt{SetupCoalitionKeys}: $\B$ forwards this request to its own oracle and returns the response.
	\item \texttt{Extract}: To an extract a decryption key for an identity $\ID=(\ID_{1},\ldots,\ID_{\ell})$ which does not match the challenge pattern, $\B$ computes the projection of the identity onto the HIBE identity space to give a projected identity $\hat{\ID}=(\hat{\ID}_{1}\ldots, \hat{\ID}_{\hat{\ell}})$.
		\begin{itemize}
		\item If $\ell \leq \ell^{*}$ then $\hat{\ell} \gets \pi(\ell)$ and $\hat{\ID}_{\pi(i)} \gets \ID_{i}$ for $i\notin W(P^{*}_{\leq \ell})$. Since $\ID$ does not match the challenge pattern for the WIBE, we have that $\hat{\ID}$ does not match the challenge identity for the HIBE. $\B$ queries its $\texttt{Extract}$ on $\hat{\ID}$ and receives $(\hat{h},\hat{a}_{0},\ldots,\hat{a}_{\hat{\ell}})$ in response. $\B$ now ``retro-fits'' to find a complete key, by setting
			\begin{displaymath}
			\begin{array}{rcl}
			a_{0} &\gets& \hat{a}_{0}\\
			a_{i} &\gets& \hat{a}_{\pi(i)} \qquad \;\mbox{ for }1\leq i\leq \ell \mbox{ and } i\notin W(P^{*}_{\leq \ell})\\
			a_{i} &\gets& g_{1}^{r_{i}} \qquad \quad \mbox{ for }1\leq i\leq \ell \mbox{ and } i\in W(P^{*}_{\leq \ell})\mbox{ where } r_{i}\getsr \mathbb{Z}_{p}\\
			h &\gets& \hat{h} \prod_{i=1, i\in W(P^{*}_{\leq \ell})}^{\ell} (u_{i,0} \cdot u_{i,1}^{\ID_{i}})^{r_{i}}
			\end{array}
			\end{displaymath}
			and returning the key $(h,a_{0},\ldots,a_{\ell})$.
		\item If $\ell > \ell^{*}$, then $\hat{\ell} = \ell - |W(P^{*})|$, $\hat{\ID}_{\pi(i)} \gets \ID_{i}$ for $1\leq i\leq \ell^{*}$ and $i\notin W(P^{*})$, and $\hat{\ID}_{i-|W(P^{*})|} \gets \ID_{i}$ for $\ell^{*} < i\leq \ell$. Since $\ID$ does not match the challenge pattern for the WIBE, we have that $\hat{\ID}$ does not match the challenge identity for the HIBE. $\B$ queries its $\texttt{Extract}$ on $\hat{\ID}$ and receives $(\hat{h},\hat{a}_{0},\ldots,\hat{a}_{\hat{\ell}})$ in response. $\B$ now ``retro-fits'' to find a complete key, by setting
			\begin{displaymath}
			\begin{array}{rcl}
			a_{0} &\gets& \hat{a}_{0}\\
			a_{i} &\gets& \hat{a}_{\pi(i)} \qquad \qquad \; \,\mbox{ for }1\leq i\leq \ell^{*} \mbox{ and } i\notin W(P^{*})\\
			a_{i} &\gets& g_{1}^{r_{i}} \qquad \qquad \quad \, \mbox{ for }1\leq i\leq \ell^{*} \mbox{ and } i\in W(P^{*})\mbox{ where } r_{i}\getsr \mathbb{Z}_{p}\\
			a_{i} &\gets& \hat{a}_{i-|W(P^{*})|} \qquad \mbox{ for } \ell^{*} <i\leq \ell\\
			h &\gets& \hat{h} \prod_{i=1, i\in W(P^{*})}^{\ell^{*}} (u_{i,0} \cdot u_{i,1}^{\ID_{i}})^{r_{i}}
			\end{array}
			\end{displaymath}
			and returning the key $(h,a_{0},\ldots,a_{\ell})$.
			\item $\texttt{Test}$: If $\A$ queries the test oracle on two equal-length messages $(m_{0},m_{1})$, then $\B$ forwards this query on to its own $\texttt{Test}$ oracle. The oracle returns $(C^{*}_{1},C^{*}_{2,0},\hat{C}^{*}_{2,1},\ldots,\hat{C}^{*}_{2,\pi(\ell^{*})},C^{*}_{3})$. $\B$ retro-fits this to form a challenge ciphertext for $\A$, by setting
				\begin{displaymath}
				\begin{array}{rcll}
				C^{*}_{2,i} &\gets& \hat{C}^{*}_{2,\pi(i)} & \qquad \mbox{ for } 1\leq i\leq \ell^{*}, i\notin W(P^{*})\\
				C^{*}_{2,i} &\gets& (\psi(C^{*}_{1})^{\beta_{i,0}},\psi(C^{*}_{1})^{\beta_{i,1}}) & \qquad \mbox{ for } 1\leq i\leq \ell^{*}, i\in W(P^{*})
				 \end{array}
				\end{displaymath}
				$\B$ returns $(C^{*}_{1},C^{*}_{2,0},\ldots,C^{*}_{2,\ell^{*}},C_{3})$ to $\A$ as the challenge ciphertext.
		\end{itemize}
		$\A$ terminates by outputting a big $b'$ as its guess for the challenge bit $b$.
	\end{itemize}
	\item $\B$ outputs the bit $b'$.
\end{enumerate}
The algorithm $\B$ correctly simulates the oracles to which $\A$ has access; furthermore, $\B$ wins the HIBE game if and only if $\A$ wins the game. Hence, we have the theorem. \qed

\begin{theorem}
If there exists an attacker $\A$ against the selective-identity multiple TA IND-WID-CPA secure of the Boneh-Boyen HIBE that runs in time $t$ and has advantage $\epsilon$, then there exists an algorithm $\B$ that solves the DBDH problem that runs in time $t'=O(t)$ and has advantage $\epsilon' \geq \epsilon -q_{K}/p$.
\end{theorem}
\emph{Proof} We directly describe the algorithm $\B$ against the DBDH problem:
\begin{enumerate}
\item $\B$ receives the input $(g,g^{a},g^{b},g^{c},Z)$.
\item $\B$ runs $\A$ to obtain the challenge coalition $\TA^{*}=\{\TA^{*}_{1},\ldots,\TA^{*}_{n^{*}}\}$ and the challenge identity $\vec{\ID^{*}}=(\ID^{*}_{1},\ldots,\ID^{*}_{\ell^{*}})$ under the challenge trust authority $\TA^{*}_{1}$. (We assume, without loss of generality, that the challenge identity is under the trusted authority $\TA^{*}_{1}$.)
\item If $\ell^{*} < L$ then randomly generates $\ID^{*}_{\ell^{*}+1},\ldots,\ID^{*}_{L}\getsr \Zbb_{p}$.
\item $\B$ computes the challenge parameters
	\begin{displaymath}
	\begin{array}{c}
	g_{1} \gets g \qquad g_{2}\gets g^{b} \qquad k_{i,j}, \alpha_{j} \getsr \Zbb_{p}^{*} \mbox{ for } 0\leq i\leq L, j\in \{0,1\}\\
	pk_1 \gets g^{a}/g^{\sum_{j=2}^{n^{*}} \alpha_{j}} \qquad pk_j \gets g^{\alpha_{j}} \mbox{ for } 2\leq j\leq n^{*}\\
	u_{0,0} \gets g_{1}^{k_{0,0}}\cdot (g^{a})^{-\TA^{*}_{1}5k_{0,1}} \qquad u_{0,1} \gets (g^{a})^{\alpha_{0,1}}\\
	u_{i,0} \gets g_{1}^{k_{i,0}}\cdot (g^{a})^{-\ID^{*}_{i}\alpha_{i,1}} \qquad u_{i,1} \gets (g^{a})^{\alpha_{i,1}} \qquad \mbox{ for } 1\leq i\leq L
	\end{array}
	\end{displaymath}
\item $\B$ runs $\A$ on the public parameters $(g_{1},g_{2},u_{0,0},u_{0,1},\ldots,u_{L,0},u_{L,1})$. If $\A$ makes an oracle query and $\B$ answers queries as follows:
	\begin{itemize}
	\item $\texttt{CreateTA}(\TA_i)$: If $\TA_i = \TA^{*}_1$ then $\B$ returns $\pk_1 = g^{a}/g^{\sum_{j=2}^{n^{*}} \alpha_{j}}$. If $\TA \neq \TA^{*}$ then $\B$ generates $\alpha_i \getsr \Zbb_{p}$ and returns $\pk_i = g_{1}^{\alpha_i}$ as described above.
	\item $\texttt{Corrupt}(\vec{\ID})$: For $\vec{\ID} = \TA_i$, we have $\TA_i \neq \TA^{*}$ for this to be a valid query; hence, $\B$ returns $g_{2}^{\beta_i}$. For $\vec{\ID}$ as a subordinate user, we require that $\TA\neq \TA^{*}_{1}$ or $\vec{\ID}$ is not ancestor of $\vec{\ID^{*}}$ where $\vec{\ID}=(\ID_{1},\ldots,\ID_{\ell})$. If $\TA\neq \TA^{*}_{1}$ then we may extract a decryption key using the extract algorithm and the master secret key of $\TA$. If $\TA=\TA^{*}_{1}$ and there must exist an index $1\leq j\leq L$ such that $\ID_{j} = \ID^{*}_{j}$, then $\B$ generates $r_{0},\ldots,r_{\ell}\getsr \Zbb_{p}$ and computes the decryption key $(h,a_{0},\ldots,a_{j})$ for $(\ID_{1},\ldots,\ID_{j})$ as
		\begin{eqnarray*}
		h &\gets& g_{2}^{\frac{-\alpha_{j,0}}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}} \cdot g_{2}^{\sum_{j=2}^{n^{*}}\beta_{j}}\cdot \left(u_{0,0}\cdot u_{0,1}^{\TA}\right)^{r_{0}} \cdot \prod_{i=1}^{j} \left(u_{i,0}\cdot u_{i,1}^{\ID_{i}}\right)^{r_{i}}\\
		a_{i} &\gets& g_{1}^{r_{i}} \mbox{ for } 0\leq i\leq j-1\\
		a_{j} &\gets& g_{2}^{-\frac{1}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}} \cdot g_{1}^{r_{j}}
		\end{eqnarray*}
		$\B$ computes the decryption key for $\vec{\ID}$ using the key derivation algorithm and returns the result. If no such $j$ exists then $\B$ aborts.

	\item $\texttt{SetupCoalitionBroadcast}(\TA_i, \sk_i,(\TA_j, \pk_j) \forall \TA_j \in \C)$: For this to be a valid request we must have $\TA_i \in \C$. For $\TA_i \neq \TA^{*}_{1}$, $\B$ can compute the private key directly; hence, $\B$ can return the correct value using the appropriate algorithm. For $\TA_i=\TA^{*}_{1}$, $\B$ generates $r_{0}\getsr \Zbb_{p}$ and computes
		\begin{eqnarray*}
		w_{i,0} &\gets& g_{2}^{\frac{-\alpha_{0,0}}{\alpha_{0,1}(\TA_{i}-\TA^{*}_{1})}} \cdot g_{2}^{\sum_{j=2}^{n^{*}}\beta_{j}} \cdot \left( u_{0,0} \cdot u_{0,1}^{\TA_{i}} \right)^{r_{0}}\\
		w_{i,1} &\gets& g_{2}^{-\frac{1}{\alpha_{0,1}(\TA_{i}-\TA^{*}_{1})}}g_{1}^{r_{0}}
		\end{eqnarray*}
		for $1\leq i\leq n$ and sets $w_{i}\gets (w_{i,0},w_{i,1})$. $\B$ outputs a list of TA/message pairs $((\TA_{i},w_{i}))_{i=1}^{n}$.
		
	\item $\texttt{Test}(m_{0},m_{1})$: For this query to be valid, we require that $|m_{0}|=|m_{1}|$. $\B$ chooses a random bit $b\getsr \{0,1\}$ and computes the ciphertext 
		\begin{displaymath}
		C^{*} \gets (g^{c},(g^{c})^{\alpha_{1,0}}, \ldots, (g^{c})^{\alpha_{\ell^{*},0}}, m_{b}\cdot Z) \, .
		\end{displaymath}
		$\B$ returns the ciphertext $C^{*}$.
	\end{itemize}
	$\A$ terminates with the output of a bit $b'$.
\item If $b=b'$ then $\B$ outputs 1. Otherwise, outputs 0.
\end{enumerate}

The $\texttt{Corrupt}$ oracle for subordinates works perfectly providing that $\B$ does not abort. The simulator only occurs if $\vec{\ID^{*}}\neq \vec{\ID}$, $\vec{\ID^{*}}$ is an ancestor of $\vec{\ID}$, and $\vec{\ID}$ is an ancestor of $(\ID^{*}_{1},\ldots,\ID^{*}_{L})$. In particular, this means that $\ID_{\ell^{*}+1} = \ID^{*}_{\ell^{*}+1}$, which occurs with probability $1/p$ as this value is information theoretically hidden from $\A$. Hence, the probability that this does not occur in the entire execution of $\A$ is $q_{K}/p$ where $q_{K}$ is the number of queries to the $\texttt{Corrupt}$ oracle. To show that if the simulator doesn't abort, the $\texttt{Corrupt}$ returns a correct key, not that it suffices to show that 
\begin{displaymath}
\sk_1 \left(u_{j,0}\cdot u_{j,1}^{\ID_{j}}\right)^{r} = g_{2}^{\frac{-\alpha_{j,0}}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}} \cdot g_{2}^{-\sum_{i=2}^{n^{*}} \beta_{i}} \qquad \mbox{ for } \qquad r = -\frac{b}{\alpha_{0,1}(\ID_{j}-\ID^{*}_{j})}\, .
\end{displaymath}
We note that $\sk_1 = g_{2}^{a-\sum_{i=2}^{n^{*}} \beta_{i}}$. The correct decryption key is
\begin{eqnarray*}
\sk_1 \left(u_{j,0}\cdot u_{j,1}^{\ID_{j}}\right)^{r} &=& g_{2}^{a-\sum_{i=2}^{n^{*}} \beta_{i}} \left( g^{\alpha_{j,0}} \cdot (g^{a})^{-\alpha_{j,1}\ID^{*}_{j}} \cdot (g^{a})^{\alpha_{j,1}\ID_{j}} \right)^{-\frac{b}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}}\\
&=& g^{ab} g_{2}^{-\sum_{i=2}^{n^{*}}\beta_{i}} \left( g^{\alpha_{j,0}} \cdot (g^{a})^{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})} \right)^{-\frac{b}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}} 
\\
&=& g^{ab} g_{2}^{-\sum_{i=2}^{n^{*}}\beta_{i}} (g^{b})^{\frac{-\alpha_{j,0}}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}}g^{-ab}\\
&=& g_{2}^{\frac{-\alpha_{j,0}}{\alpha_{j,1}(\ID_{j}-\ID^{*}_{j})}} g_{2}^{-\sum_{i=2}^{n^{*}}\beta_{i}}\\
\end{eqnarray*}
Hence, $\B$'s simulation returns a correct decryption key. Similarly, the $\texttt{SetupCoalitionBroadcast}$ algorithm gives correct broadcast messages for $\TA^{*}_{1}$. All other oracles that $\B$ provides (except, perhaps, the $\texttt{Test}$ oracle) correctly simulate the security model for $\A$.

If $Z=e(g,g)^{abc}$ then the $\texttt{Test}$ oracle provides a correct encryption of $m_{b}$. This is because an encryption using the random value $c$ would have 
\begin{eqnarray*}
C_{1} &=& g_{1}^{c}=g^{c}\\
C_{2,0} &=& (u_{0,0} \cdot u_{0,1}^{\TA^{*}_{1}})^{c} = (g^{\alpha_{0,0}})^{c} = (g^{c})^{\alpha_{0,0}}\\
C_{2,i} &=& (u_{i,0} \cdot u_{i,1}^{\ID^{*}_{i}})^{c} = (g^{c})^{\alpha_{i,0}} \qquad \mbox{ for } 1\leq i\leq \ell^{*}\\
C_{3} &=& m_{b} \cdot e(\prod_{i=1}^{n^{*}} \pk_i,g_{2})^{c}
= m_{b} \cdot e(g^{a},g^{b})^{c} = m_{b} \cdot e(g,g)^{abc}
\end{eqnarray*}
The probability that $\B$ outputs 1 in this situation is the probability that $b=b'$ in the mTA-IND-WID-CPA game for the attacker $\A$. If $Z$ is random then the $\texttt{Test}$ oracle information theoretically hides $b$ and so the probability that $\B$ outputs 1 in this situation is $1/2$. Hence, the probability that $\B$ wins the DBDH is $\epsilon-q_{K}/p$. \qed


\section{Non-Selective Identity Security in the Random Oracle Model}

Like the Boneh-Boyen HIBE it is based on \cite{Boneh04}, the multi-$\TA$ scheme is only proven secure in the (selective-identity) multi-TA IND-sWID-CPA model. For non-wildcard single $\TA$ schemes, selective-identity IND-s(H)ID security in the standard model can be transformed into non-selective-identity secure IND-(H)ID schemes in the random oracle model \cite{Boneh05}. This technique was extended to securely enable wildcards in IND-sHID-CPA WIBE schemes \cite{Abdalla06} and we further extend it to prove non-selective-identity security of our proposed multi-$\TA$ scheme in the random oracle model.

The security game in the random oracle model is the same as in the standard model with the addition of one new oracle \cite{Bellare93}. This oracle responds to each query with a uniformly random element chosen from its output domain. Additionally, for each specific query the response is always the same whenever that query is made. 

%FIXME - rewrite for clarity
To prove security in a non-selective-identity setting we alter the routines of the multi-TA WIBE scheme to use the hash of an identity ($H_i(\ID_i)$) rather than the identity ($\ID_i$) for each level $i$.  The key derivation and encryption routines pass the identity to a hash function (modeled as a random oracle) and use the result in place of the identity in the relevant algorithm. This hash function maps from the finite space of identifiers to an equal or smaller sized target space. This transform changes the pattern $\vec{P} = (P_1, P_2, ..., P_\ell)$ into pattern $H(P) = \vec{P}' = (P_1', P_2', ..., P_\ell')$ as follows:
$$P_i' = H_i(P_i) \textrm{ for } i \notin W(P), \textrm{ otherwise } H(P_i) = * = P_i'$$

We note that a finite family of independent random oracles of predetermined maximum size may be simulated using a single random oracle. Given a single random oracle $H(\textrm{query})$, a WIBE of maximum depth $L$. and a fixed-length format to enumerate $i \in \{1 \ldots L\}$, we may create $i$ independent random oracles. Each oracle $H_i(\textrm{query})$ corresponding to level $i$ of the WIBE is simulated by prepending the query with the number of the oracle it is addressed to, $H_i(\textrm{query}) = H(i || \textrm{query})$.

\begin{theorem}
Suppose that there exists a polynomial-time attacker $\A$ against the non-selective-identity multiple TA IND-WID-CPA Boneh-Boyen WIBE with advantage $\epsilon$ with access to $q_H$ queries from each of the $L$ random oracles associated with hierarchy levels, then there exists a polynomial-time attacker $\B$ against the selective-identity multiple TA IND-sWID-CPA Boneh-Boyen WIBE with advantage $\epsilon'$ when allowed $q_K$ key derivation queries with $\epsilon'$ bounded:
$$\epsilon' \ge \left(\frac{\epsilon}{2^n L (q_H + 1)^L}\right)\left(1 - \frac{(q_H + 1)}{|\mathcal{\ID}|}\right)^L$$
\end{theorem}
\emph{Proof} Suppose there exists adversary $\A$ against the multi-TA IND-WID-CPA scheme (with hashed identities), we will construct an adversary $\B$ which gains an advantage against the multi-TA IND-sWID-CPA scheme using the algorithm $\A$ as a black box.

For a multi-TA WIBE of maximum depth $L$ consisting of a maximum of $k$ $\TA's$, the algorithm $\B$ runs as follows:

\begin{enumerate}
	\item $\B$ randomly chooses a length $\ell^* \in \{1 \ldots L\}$ for its challenge identity vector. Also, $\B$ randomly chooses a coalition $\vec{\TA}^{*} = (\TA^{*}_{1},\ldots,\TA^{*}_{n})$ from all possible non-empty combinations of the $k$ $\TA$'s. The numbering assignment of $\TA$'s in the coalition is assigned randomly.
	\item $\B$ chooses a challenge pattern $\vec{P}^*$ as follows. First, $\B$ randomly assigns a family $t_i \getsr \{0, 1, ..., q_H\}$ for all $i \in \{1, ..., \ell\}$. If $t_i = 0$ then $\B$ assigns $P_i = *$. For $t_1 \neq 0$ $\B$ randomly chooses $P_1 \getsr \{\TA_1, *\}$. For $i > 1$ with $t_i \neq 0$ $\B$ randomly chooses $P_i \getsr \mathcal{ID}$
	\item The challenger responds with WIBE parameters $\mathit{param} = (\hat{g}_{1},\hat{g}_{2},\hat{u}_{0,0},\ldots,\hat{u}_{L,1})$. $\B$ initiates $\A$ with the same parameters and a family of hashes $H_i$ for each level $i$ allowed in the HIBE.
	\item Since both $\B$ and $\A$ are in WIBE environments playing the chosen plaintext game, they have access to the same set of oracles with $\A$ having access to an additional random oracle. To prepare for random oracle queries from $\A$, $\B$ initializes associative lists $J_i$ for each level $i$ allowed in the HIBE to answer queries for each oracle $H_i$. Initially empty, $\B$ must either track the number of entries made on each list with a counter or equivalently through measure of its size, we let $|J_i| \gets 1$ denote the size of empty lists. When $\A$ queries random oracle $H_i$ on identity $\ID$, $\B$ answers as follows:
	\begin{itemize}
		\item If $J_i(\ID)$ has been previously defined, then $\B$ returns $J_i(\ID)$.
		\item Otherwise:
		\begin{itemize}
			\item For $t_i = J_i$, if $i = 1$ then $\B$ assigns the value $J_1(\ID) \gets \TA_1$. If $i \neq 1$ then $\B$ assigns the value $J_i \gets P_i^{*}$.
			\item For $t_i \neq J_i$, $\B$ assigns $J_i(\ID) \gets H_i(\ID)$ and increments the counter $|J_i|$.
			\item $\B$ then returns the value $J_i(\ID)$
		\end{itemize}
	\end{itemize}
	\item For other queries, $\B$ hashes the relevant identity pattern $\vec{P}$ as a random oracle query with result $\vec{P}'$. Note that for $\TA$-level queries with $\vec{\ID} = (\TA_i)$ the pattern is still transformed as $\vec{\ID}' = (J_1 (\TA_i))$. $\A$ may query:
	\begin{itemize}
		\item \texttt{CreateTA}($\TA_i$) $\B$ computes $\TA_i' = J_1(\TA_i)$ and queries its own oracle as $\texttt{CreateTA}(\TA_i')$, returning the result.
		\item \texttt{Corrupt}($\vec{P}$) If $J(\vec{P}) \in_* \vec{P^*}$ then $\B$ aborts because it would have to make an illegal query. Otherwise, $\B$ computes $\vec{P}' = J(\vec{P})$ and forwards the query using its own oracle as \texttt{Corrupt}($\vec{P}'$), returning the result.
		\item \texttt{SetupCoalitionBroadcast}($\TA_i, \C$) For each $\TA_j$ in the coalition $\C$, $\B$ computes the hashed $\TA$ identity $\TA_j' = J_1(\TA_j)$ and adds it to coalition $\C'$. $\B$ also computes the hashed identity $\TA_i' = J_1(\TA_i)$ then forwards the query as \texttt{SetupCoalitionBroadcast}($\TA_i', \C'$), returning the result.
		\item \texttt{SetupCoalitionKeys}($\TA_j, \sk_j, \C, \hat{W}_j$) For each $\TA_j$ in the coalition $\C$, $\B$ computes the hashed $\TA$ identity $\TA_j' = J_1(\TA_j)$ and adds it to coalition $\C'$. $\B$ then computes $\TA_j' = J_1(\TA_j)$ and forwards the query as \texttt{SetupCoalitionKeys}($\TA_j', \sk_j, \C$), returning the result.
		\item \texttt{ExtractCoalitionKey}($\C, v_j, d_{\vec{\ID}}$) For each $\TA_j$ in the coalition $\C$, $\B$ computes the hashed $\TA$ identity $\TA_j' = J_1(\TA_j)$ and adds it to coalition $\C'$. $\B$ then computes $\vec{\ID}' = J(\vec{\ID})$ and queries \texttt{ExtractCoalitionKey}($\C', v_j, d_{\vec{\ID'}}$), returning the result.
	\end{itemize}
	\item $\A$ ends this stage of the game by outputting a challenge pattern $\widehat{\vec{P}} = (\widehat{P}_1, ..., \widehat{P}_{\ell})$ and challenge coalition $\widehat{\vec{\TA}} = \{\widehat{\TA_1}, ..., \widehat{\TA_k}\}$ and two equal-length messages $(m_0, m_1)$. If any $J_i(\widehat{P}_i)$ has not yet been defined then $\B$ sets $J_i(\widehat{P}_i) \gets H_i(\widehat{P}_i)$.
	\item $\B$ must abort if:
		\begin{itemize}
			\item if $\ell \neq \ell^{*}$
			\item if there exists $i \in W(\widehat{\vec{P}})$ such that $i \notin W(\vec{P}^{*})$
			\item if $J_i(\widehat{P_i}) \neq P^{*}_i$
			\comment{\item if $J_1(\widehat{\TA_i}) \notin \vec{\TA}^{*}$}
			\item if $|\vec{\widehat{\TA}}| \neq |\vec{\TA}^{*}|$
		\end{itemize}
	\item If $\B$ has not aborted it outputs the messages $(m_0, m_1)$ to the challenger.
	\item The challenger computes the challenge ciphertext $C^{*}$ by encrypting message $m_\beta$ for $\beta \getsr \{0, 1\}$ and returns it to $\B$.
	\item $\B$ in turn returns the challenge ciphertext to $\A$, which outputs a bit $\widehat{\beta}$ as a guess for the value of $\beta$.
	\item In turn, $\B$ outputs $\widehat{\beta}$ as its guess for the value of $\beta$.
\end{enumerate}

The algorithm $\B$ wins the IND-sWID-CPA game if $\A$ wins the IND-WID-CPA game and $\B$ does not abort. $\B$ may abort if it has guess the challenge coalition and pattern incorrectly, or if it was forced to make an illegal query. $\B$ uses the $t_i$'s to guess which of $\A$'s queries will be used to define the $i^{\textrm{th}}$ level of its challenge pattern with $t_i =0$ corresponding to a wildcard.

To avoid $\B$'s making of an illegal query we require that there are no collisions in the hash. For distinct identifiers $\ID \ne \ID'$ we require that the hash output $H_i(\ID) \ne H_i(\ID')$. With a random oracle such a collision could only occur by chance. Given $(q_H + 1)$ random oracle queries for a level the probability of a collision has an upper bound of $(q_H + 1)/|\mathcal{\ID}|$. Then the probability of successfully avoiding a collision has a lower bound of $(1 - (q_H + 1)/|\mathcal{\ID}|)$. With $L$ independent random oracles, the probability of avoiding a collision on all levels is then $(1 - (q_H + 1)/|\mathcal{\ID}|)^L$. If a collision occurs then $\B$ will gain no benefit from $\A$'s advantage as it cannot properly simulate the WIBE environment. Of $\A$'s original advantage $\epsilon$, $\B$ may only leverage an advantage of $\epsilon(1 - (q_H + 1)/|\mathcal{\ID}|)^L$.

We require that $\B$ correctly choose the challenge pattern and coalition in order to win the game. The probability that $\ell = \ell^*$ is $1/L$, the probability that $t_i$ correctly identifies $P_i$ is $1/(q_H + 1)$ for each level $i \le L$, and the probability of the challenge coalition $\C$ being correct as $1/2^n$. Each of these factors reduce $\B$'s advantage multiplicatively in comparison to $\A$'s. If $\B$ correctly guesses these values and $\A$ never forces $\B$ to make an illegal query then $\B$ has advantage:
$$\epsilon' \ge \left(\frac{\epsilon}{2^n L (q_H + 1)^L}\right)\left(1 - \frac{(q_H + 1)}{|\mathcal{\ID}|}\right)^L$$
\qed

\section{Chosen-Ciphertext Security}
Transforming an adaptive chosen-plaintext secure (CPA) secure IBE scheme into a CCA-secure public-key scheme was originally proposed by Canetti, Halevi, and Katz \cite{CHK}. Their method was later improved for efficiency by Boneh and Katz \cite{BK}, and further research by Boyen, Mei, and Waters \cite{BMW} allowed for transformations with fewer dependencies outside the initial IBE scheme. Each of these methods allows for a parallel transformation of selective-identity CPA-secure IBE schemes in the standard model into nonselective-identity CCA-secure public-key scheme in the random oracle model using a proof similar to the one above.

We present a transformation descended from the Park and Lee's proof \cite{Park07} which directly transforms a selective-identity CPA-secure $L+1$ level multi-TA WIBE into a selective-identity CCA-secure $L$ level multi-TA WIBE in the standard model. While requiring a one-time signature scheme as in the original Canetti, Halevi, and Katz transformation, the Park and Lee transformation (and our extension thereof) does not require the padding of identities by one bit.

To achieve sWID-IND-CCA chosen-ciphertext security we require the addition of a strongly unforgeable signature scheme \emph{Sig = (SigKeyGen, Sign, Verify)} and a collision resistant hash function mapping verification keys to $\Zbb_p$ where $p$ is the order of $\Gbb$. For simplicity, we will assume a natural map of verification keys to $\Zbb_p$ and treat the keys as members of the finite field directly. Recall that $\Gbb$ is the group from which the public parameters of the HIBE are chosen, and that there is a bilinear map $e: \Gbb \times \Gbb \rightarrow \Gbb_T$ mapping onto the message space $\Gbb_T$. In mapping onto a WIBE of one fewer levels, the public parameters for the $L+1$ level are appropriated for the verification code. The new public parameters for the Boneh-Boyen based multi-TA WIBE become:

$$\{g_1, g_2, u_{1,0}, u_{1,1}, u_{2,0}, u_{2,1}, \ldots, u_{L,0}, u_{L,1}, u_{v,0}, u_{v,1}\} \in \Gbb$$
$$\textrm{And the set of $\TA$s } \{\TA_1, \TA_2, \ldots, \TA_n\}$$

The algorithms for key delegation, encryption, and decryption must be altered to incorporate verification codes. The algorithms change as follows:

\begin{itemize}
	\item \texttt{KeyGen}($d_{\vec{\ID}}$, $\vec{ID}'$) Node $\vec{ID} = (\ID_1, \ldots, \ID_j)$ generates a secret key $d_{\vec{\ID}'}$ for subordinate node $\vec{ID}' = (\ID_1, \ldots, \ID_j, \ID_{j+1}, \ldots, \ID_\ell)$ using its private key $d_{\vec{\ID}} = (h, a_1, \ldots, a_j)$ as follows:
		$$d_{\vec{\ID}'} = (h \cdot \prod_{k = 1}^\ell (u_{k, 0} \cdot u_{k,1}^{\ID_k})^{r_k}, a_1 \cdot g^{r_1}, a_2 \cdot g^{r_2}, \ldots, a_j \cdot g^{r_j}, g^{r_{j+1}}, g^{r_{j+2}}, \ldots, g^{r_\ell})$$
	\item \texttt{Encrypt}($m$, $\vec{P}$, $\C$) To encrypt message $m$ to pattern $\vec{P} = (P_1, P_2, \ldots, P_\ell)$ in coalition $\C$ with coalition-specific public key $pk_\C$ the sender randomly chooses $t \getsr \Zbb_p$. The sender runs the \emph{SigKeyGen} signing key generator algorithm to obtain a signing key $S$ and corresponding verification key $K$. The sender then computes:
	\begin{eqnarray*}
		C_{1} & \gets & g_{1}^{t} \\
		C_{2,v} & \gets & (u_{v, 0} \cdot u_{v,1}^K)^t\\
		C_{2,i} & \gets & \left\{
			\begin{array}{ll}
				(u_{i,0} \cdot u_{i,1}^{\ID_{i}})^{t} & \qquad \mbox{if } i \notin W(P) \\
				(u_{i,0}^{t},u_{i,1}^{t}) & \qquad \mbox{if } i \in W(P)
			\end{array}
		\right. \\
		C_{3} &\gets& m \cdot e(\pk_\C,g_{2})^{t}\\
		C \gets (C_1, C_{2,k}, C_3, Sign_{K}(C)) \textrm{ for } k\in\{1 \ldots \ell, v\}
	\end{eqnarray*}
	The ciphertext is then sent as:
	$$\vec{CT} = (C, Sign_S(C), V) \textrm{ where } S \textrm{ and } V \textrm{ are related signing and verification keys respectively}$$
	\item \texttt{Decrypt}($\vec{CT}$, $\C$, $d_{\vec{\ID}}$) A ciphertext $\vec{CT} = (C, \sigma, V)$ encrypted to pattern $P$ under coalition $\C$ may be decrypted by an entity $\vec{\ID} = \{\ID_1, \ID_2, \ldots, \ID_\ell\} \in^* P$ holding key $d_{\vec{\ID}} = (h, a_1, a2, \ldots, a_\ell)$ specific to coalition $\C$. The decrypting node first verifies that signature $\sigma$ of ciphertext $C$ is valid under verification key $V$, if invalid outputting $\perp$. If the verification succeeds the ciphertext is then decrypted by choosing randomly $s \getsr \Zbb_p$ and computing:
	\begin{eqnarray*}
		C'_{2,i} & \gets & \left\{
			\begin{array}{ll}
				C_{2,i} & \qquad \mbox{if } i \notin W(P) \\
				(C_{2,i,0} \cdot C_{2,i,1}^{\ID_i}) & \qquad \mbox{if } i \in W(P)
			\end{array}
			\right. \\
			m' & \gets & C_{3} \frac{\prod_{i=1}^{\ell} e(a_{i},C'_{2,i}) \cdot e(C_{2,v}, g_1^s)}{e(C_{1},h \cdot (g_1^V \cdot h)^s)}
	\end{eqnarray*}
\end{itemize}

\begin{theorem}
Suppose that there exists a polynomial-time attacker $\A$ against the multiple TA IND-sWID-CCA signed-ciphertext Boneh-Boyen WIBE with advantage $\epsilon$, then there exists a polynomial-time attacker $\B$ against the Bilinear Decisional Diffie-Hellman (BDDH) problem with advantage $\epsilon'$.
\end{theorem}
\emph{Proof} Suppose there exists adversary $\A$ against the multi-TA IND-sWID-CCA scheme (with verification codes), we will construct an adversary $\B$ which gains an advantage against the multi-TA IND-sWID-CPA scheme using the algorithm $\A$ as a black box.

For a multi-TA WIBE of maximum depth $L$ consisting of a maximum of $k$ $\TA's$, the algorithm $\B$ runs as follows:

\begin{enumerate}
	\item $\B$ receives BDDH input $(g, g^a, g^b, g^c, Z)$ for some unknown $a, b, c \in \Zbb_p^*$ and must decide whether $Z = g^{abc}$ and output $1$ is true and $0$ otherwise.
	\item $\B$ initializes $\A$ for the decided number of WIBE levels and $\TA$s. $\A$ returns challenges coalition $C^*$ and challenge pattern $\vec{P}^* = (P^*_1, P^*_2, \ldots, P^*_\ell)$ with $P_{i} \in \Gbb \cup \{*\}$ that $\A$ intends to attack. If $\vec{P^*}$ does not extend to the maximum level $L$ then $\B$ randomly chooses elements $(P*_{l+1}, \dots, P^*_{L}) \in \Zbb_p$. Next $\B$ runs \emph{SigKeyGen} to obtain signing key $S$ and verification key $K$ and 
	\item $\B$ announces public parameters the 
\end{enumerate}

\begin{comment}
\section{Features}
\begin{itemize}
	\item Completed
	\begin{itemize}
		\item Multi-TA HIBE
		\item Wildcard one-to-many addressing in multi-TA WIBE
		\item Instantiation in Boneh-Boyen-Goh
		\item Security proof of instantiation with coalition updates allowed
		\item Coalition updates
		\item Within TA broadcast messages
		\item Efficient subordinate key updates for coalition updates
	\end{itemize}
	\item In Process
	\begin{itemize}
		\item CHK transform from CPA to CCA
		\item Subordinate-initiated coalitions (Dual-HIBE $\rightarrow$ Dual-WIBE)
		\item Instatiation and proof based on Waters HIBE for non-selective ID-CPA
		\item Waters + CHK for true IND-WID-CCA
	\end{itemize}
	\item Desired
	\begin{itemize}
		\item Many levels without loss of security (Gentry's fabulous matrix method?)
		\item TA-anonymity of message (sender anonymity? Sender and recipients?)
		\item Reduced SetupCoalition requirements (currently $O(n^2)$)
		\item Security proof on abstracted model (e.g. all commutative blinding schemes)
	\end{itemize}
\end{itemize}
\end{comment}


\begin{comment}%old comments, review and remove
	
\section{Comments}
	Alex wrote:\\
	What's to prevent an attacker setting up his own TA under the name of a real coalition member and then hijacking the update coalition protocol? Are we going to assume trusted distribution of master public keys?\\\\
	Chris wrote:\\
	In BBG, UpdateCoalitionBroadcast has a dependency on the correlation between the public messages and the secret key.  In BB, the power $\alpha_i$ to which we raise $g_2$ is the same in all messages, but irretrievable due to the random element $r_{i,j}$.  UpdateCoalitionBroadcast is inherently insecure if if doesn't require knowledge of a TA's secret key, e.g. if we allow a TA to change $\alpha_i$ and all $r_{i,j}$'s at the same time and in the clear.  A non-corrupted TA should be safe from hijack if either UpdateCoalitionBroadcast messages are sent encrypted to members of the existing coalition or if broken into two algorithms: first an AdmitNewMembersBroadcast which sends $w_{i,j}$ messages for  $\TA_i \in \C \cap \C'$ and $\TA_j \in \C' \setminus \C$ and secondly a (possibly broadcast-) encrypted CoalitionKeyRefresh to update keys in an existing coalition (perhaps just prior to expansion or after contraction).\\\\
	How is JoinCoalitionBroadcast different from SetupCoalitionBroadcast in terms of inputs and outputs?  In other words, could joining members of a coalition run SetupCoalBcast for the expanded coalition with equivalent results? (eliminating one algorithm)\\\\
	Similarly, aren't UpdateCoalitionKeys and JoinCoalitionKeys essentially the same as SetupCoalitionKeys once the messages $w_{i,j}$ are out there? Do we keep them separate for generality, and thus need to also keep separate UpdateCoalitionKey and ExtractCoalitionKey algorithms?\\\\
	Should the coalition key adjustment ($u_i$) and the coalition key ($c_{\vec{\ID}}$) be indexed by coalition ($\C$) in addition to the identity ($\vec{\ID}$)?\\\\
	Why do we record which TAs have been corrupted?
	
	

\section{Orphaned Discussion from Prior Writing}

	\subsection{Introduction \& Motivation}
	Identity-based encryption is most often considered in the context of one-to-one communication within a single Trusted Authority (TA); every encrypted message is sent between two individual entities.  In this paper we consider a coalition of TA's desiring secure one-to-many communication, with each TA retaining security of it's secret keys.  This secrecy requirement is natural in the setting of dynamic coalition forming and dissolution.

	One-to-many secure communication is a powerful cryptographic tool.  Take a MANETs setting for example, where transmission is much more expensive than computation, one-to-many communication allows for a single transmitted message to be read by any number of valid recipients within range.  In this paper, multiple recipients may decrypt the same message through the use of one or more "wildcards". A wildcard is a special character that may be used in an address in lieu of specifying a particular aspect of an identity, allowing anyone matching the non-wildcard portion to read the message.

	In the single-TA case, the method of employing wildcards into hierarchical identity-based encryption structures (Abdallah et al., 2006) allows an individual at any level within one TA to send messages to entire levels within that TA.  The hierarchy of a TA could be as simple as an email address, every entity under the TA (say "school.edu") has a name. Considered as an IBE setting, one might desire to send a single message to an address of the form "name@school.edu", but a message pertaining to everyone at the school might be better sent to *@school.edu in a wildcard IBE setting. 

	In the multi-TA case, we could consider schools as separate Trusted Authorities.  These TA's could agree upon a protocol such as the one described in this paper to allow secure one-to-many hierarchical IBE.  As such, a message addressed to the leadership of universities could be sent to "provost@*.edu" or a message for computer system administrators might be addresses sysadmin@*.*.  The wildcard method of multicast communication is limited by the structure of the hierarchy: it cannot distinguish between entities within a single hierarchical level.  For example, a single message to "*@school.edu" could be read by "alice@school.edu", "bob@school", and "eve@school.edu"; however, it would not be possible to send a single message to Alice and Bob without also allowing Eve to read it. Likewise, a message may be addressed to a single specified TA or to all TA's by wildcard; it is impossible to select multiple TA's to receive a message without making the message readable across all TA's.

	In addition to one-to-many communication, this paper assumes that the coalition of TA's may change over time and allows those changes without compromising the security of communication or any TA's secret key.  TA's may be removed or added to the coalition with minimal configuration.  Upon a change in coalition make-up the participating TA's exchange public information, and based on non-public secret information they are able to communicate.  The private keys of subordinate entities of each TA must be updated, but each TA can accomplish this through a single broadcast message exclusively readable to members of that TA.  This flexible reconfiguration ability similarly allows a fixed set of TA's in coalition to schedule secure reconfigurations with minimal communication long before any secret key has a chance to become stale or compromised.

	An interesting consequence and possible drawback of using a hierarchical IBE is that messages sent to a subordinate entity may be decrypted by direct ancestors of that entity.  Explicitly, a message to "bob@school.edu" could be read by the entity "school.edu", but not by "eve@school.edu" or by an entity at "university.edu".  The ability to decrypt is possible because an entity's ancestors are able to generate new secret keys for subordinates, so "school.edu" can make keys for "alice@school.edu", "bob@school.edu", ad infinitum.  With the use of a centralized key distributor it may be possible to avoid this vulnerability by choosing keys in such a way as to isolate the levels of hierarchy from each other.

	\subsection{Reconfiguration}

	Should the members of the coalition of TA's change, an interesting aspect of this system is that it is quickly reconfigurable.  Reconfiguration of the system in play relies on the hierarchical organization of secret keys, the ability to broadcast messages to all members of a TA.  The security of reconfiguration relies on only the security assumptions made previously: difficulty of the BDDH under e and the discrete logarithm problem in $\mathbb{G}^+$.

	Once a new coalition is determined, the members choose $\beta_i$ and $s_{i,j}$ to replace $\alpha_i$ and $r_{i,j}$ and publish values of $(\beta_i \cdot g_1)$ for all i and $(\beta_i \cdot g_2 + s_{i,j} \cdot (u_{1,0} + ID_{j,1}\cdot u_{1,1}))$for all $i \neq j$.  As before, each TA$_j$ may then calculate their private key based on the withheld $i = j$ value, and replace the previous secret key $(a_0, a_1) = (((\Sigma \alpha_i)\cdot g_2 + \Sigma r_{i,j} \cdot (u_{1,0} + ID_{j,1}\cdot u_{1,1})), \Sigma r_{i,j} \cdot g_1)$ with the new secret key $d_{TA_j} = (b_0, b_1) = (\Sigma \beta_i \cdot g_2
	 + \Sigma s_{i,j} \cdot (u_{1,0} + ID_{j,1}\cdot u_{1,1}), \Sigma s_{i,j} \cdot g_1)$ (summation runs on the $i$ index). The public key $\Sigma \beta_i \cdot g_1$ is also calculable from the public information during this setup and should be assumed available to all TA's and subordinates.   To disseminate the new private information, the TA's could calculate an adjustment term:
	\begin{align*}
	(b_0 - a_0, b_1 - a_1) = ((\Sigma \beta_i - \Sigma \alpha_i) \cdot g_2 + (\Sigma s_{i,j} - \Sigma r_{i,j})\cdot (u_{1,0} + ID_{j,1} \cdot u_{1,1}), (\Sigma s_{i,j} - \Sigma r_{i,j})\cdot g_1)
	\end{align*}

	The savings in reconfiguration costs come from TAs needing to do a round of communication at the highest level and then allowing a broadcast of information to subordinates rather than being required to send a separate message to each subordinate using their unique private keys.

	\subsection{Properties of the Scheme}

	Our setup enables a group of TA's to use identity based encryption in a mixed trust situation. The "super secret" $\Sigma \alpha_i \cdot g_2$ is inseparable from the secret values $r,_{i,j}$ and $\alpha_i$ that the TA's do not share. In this way, no TA has enough information to decrypt messages destined for another.  It should be noted that we inherit from a hierarchical cryptosystem the property that every subordinate's key is derived from its superior. From this  it follows that every superior may read messages sent to any subordinates in the hierarchy,not just immediate subordinates.  If there were an entity above the TA's, corresponding to the "super secret",it would be able to read all messages sent in the system; for this reason we force this value to be difficult to recover by any TA or group of TA's.

	Collaborative secret creation requires revealing many pieces of information but results in a highly collusion-resistant secret. The generation process requires each TA to reveal $n$ pieces of information which are each related to the secret $\alpha_i$ that the TA must not reveal. From the security of each TAs $\alpha_i$, any two TAs colluding have no advantage over a single TA in recovering the unknown $\alpha_i$. Because no one but the target TA has this information, bringing more TAs into an attacking coalition would bring no advantage either. This can be seen by imagining the worst case scenario, $(n-1)$ TAs attacking the secret of the lone target TA. In this case, the attacker has knowledge of all $\alpha_i$s and $r_{i,j}$s except for $\alpha_k$ and $r_{k,k}$ for target TA$_k$. The attackers have knowledge of $((\Sigma \alpha_i)\cdot g_2+ r_{i,k} \cdot (u_{1,0} + ID_{k,1}\cdot u_{1,1}))$ for all $i \neq k$. From their secret and public pieces of information  the attackers would need to calculate $(\alpha_k \cdot g_2 + r_{k,k} \cdot ( u_{1,0} +ID_{k,1} \cdot u_{1,1}))$, but they cannot because $r_{k,k}$ is secret and $alpha_k$ is occluded by the discrete logarithm problem.
	Similarly, the use of independent secrets in the setup ensures that no TA can read anothers messages without knowledge of either $\Sigma \alpha_i)\cdot g_2$ or the target TAs individual $\alpha_i$. Solving either of these problems is equivalent to solving the Bilinear Diffie-Hellman problem. In the first case the attacker must be able to separate the two terms of the published $(\alpha_i \cdot g_2 + r_{i,j} \cdot (u_{1,0} + (ID_{j,1})\cdot u_{1,1}))$, which relies on knowledge of $r_{i,j}$s. In the second case the attacker must recover $\alpha_i$, from solving a discrete logarithm on public information such as $\alpha_i \cdot g_1$.

	The parameters used in encryption and decryption in this scheme does not depend on the TA membership of the sender or recipient(s) of a message (except in the sense of recipient identity). There are no TA-specific pieces of public information necessary as is sometimes the case in identity-based encryption with multiple TAs. As such, ciphertext messages may be unencumbered by information about the sender. The system is truly identity-based because a ciphertext depends only on the identity of the recipient(s). 
	One interesting question in this scenario is the security of sending a message across all TAs. Is it possible for an attacker to masquerade as an additional TA by using the public information available?
	It is interesting to note that this scheme allows for broadcast of information to many (or all) identities within TAs. The incorporation of wildcards into the scheme comes at the (low) cost of having more public parameters for the crypto-system.
\end{comment}

\bibliographystyle{alpha}
\bibliography{bibliography}
\end{document}
